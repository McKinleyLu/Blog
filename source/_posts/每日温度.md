---
title: 每日温度
toc: true
cover: /img/4.jpg
categories:
  - 竞赛
tags:
  - leetcode
abbrlink: 45221
date: 2021-07-17 07:26:54
---

### 题目描述

根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。<!-- more -->
例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。
提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。

#### 输入数据

[73,74,75,71,69,72,76,73]

#### 期望数据

[1,1,4,2,1,1,0,0]

### 分析

此种找到一个数大的值的第一个数问题，就是明摆着告诉你要用到单调栈
其实使用两次循环也可以，但是复杂度高，容易答题失败

1. 什么是单调栈
   就是一个栈，里面的元素的大小按照他们所在栈内的位置，满足一定的单调性

2. 本题如何利用单调栈

   维护一个单调递减的stack，stack内部存的是原数组的每个index。

   每当我们遇到一个比当前栈顶所对应的数大的数的时候，我们就遇到了一个“大数“。这个”大数“比它之前多少个数大我们不知道，但是至少比当前栈顶所对应的数大。

   我们弹出栈内所有对应数比这个数小的栈内元素，并更新它们在返回数组中对应位置的值。

   因为这个栈本身的单调性，当我们栈顶元素所对应的数比这个元素大的时候，我们可以保证，栈内所有元素都比这个元素大。

   对于每一个元素，当它出栈的时候，说明它遇到了自己的next greater element，我们也就要更新redult数组中的对应位置的值。如果一个元素一直不曾出栈，那么说明不存在next greater element，我们也就不用更新result数组了。

   ### 参考代码

   ```java
   class Solution {
   public:
       vector<int> dailyTemperatures(vector<int>& T) {
           vector<int> result(T.size(),0);
           stack<int> q;
           for(int i = 0  ; i < T.size() ; ++i)
           {
               while(!q.empty()&&T[q.top()] < T[i])
               {
                   result[q.top()] = i - q.top();
                   q.pop();
               }
               q.push(i);
           }
           return result;
       }
   };
   ```

