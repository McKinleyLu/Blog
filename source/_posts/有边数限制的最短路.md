<<<<<<< HEAD
---
title: 有边数限制的最短路
categories:
  - 基础算法
tags:
  - 最短路
  - week3
abbrlink: 58586
date: 2022-03-11 17:08:40
---
### 题目描述

给定一个n个点m条边的有向图，图中可能存在重边和自环， **边权可能为负数**。
请你求出从1号点到n号点的最多经过k条边的最短距离，如果无法从1号点走到n号点，输出impossible。
注意：图中可能 **存在负权回路** 。

### 输入格式

第一行包含三个整数n，m，k。
接下来m行，每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。

### 输出格式

输出一个整数，表示从1号点到n号点的最多经过k条边的最短距离。
如果不存在满足条件的路径，则输出“impossible”。

### 数据范围
```java
1≤n,k≤5001≤n,k≤500,
1≤m≤100001≤m≤10000,
任意边长的绝对值不超过10000。
```
### 输入样例

```java
3 3 1
1 2 1
2 3 1
1 3 3
```

### 输出样例

```java
3
```

### 参考代码

```java
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std ;

const int N = 510 , M = 10010;
int n , m , k;
int dist[N],backup[N];    //backup  备份dist数组
struct Edge{
    int a ,b ,w;
}edges[M];

int bellman_ford(){
    //       -2
    //  1   ---->    n
    // +∞            +∞
    memset(dist , 0x3f , sizeof dist);
    dist[1] = 0 ;
    for(int i = 0 ; i < k ; i++){
        memcpy(backup,dist,sizeof dist);
        for(int j = 0 ; j < m ; ++j){
            int a = edges[j].a, b = edges[j].b , w = edges[j].w;
            dist[b] = min(dist[b],backup[a]+w);
        }
    }

    if(dist[n] > 0x3f3f3f3f /2 )  return -10000;
    return dist[n];
}
int main(int argc, char const *argv[])
{
    cin >> n >> m >> k ;
    int i = 0 ;
    for(int i = 0 ; i < m  ; ++i){
        cin >> edges[i].a >> edges[i].b >> edges[i].w ;
    }
    
    int ans = bellman_ford();
    if(ans == -10000) puts("impossible");
    else          cout << ans <<endl;             
    return 0;
}
```

=======
---
title: 有边数限制的最短路
categories:
  - 基础算法
tags:
  - 最短路
  - week3
abbrlink: 58586
date: 2022-03-11 17:08:40
---
### 题目描述

给定一个n个点m条边的有向图，图中可能存在重边和自环， **边权可能为负数**。
请你求出从1号点到n号点的最多经过k条边的最短距离，如果无法从1号点走到n号点，输出impossible。
注意：图中可能 **存在负权回路** 。

### 输入格式

第一行包含三个整数n，m，k。
接下来m行，每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。

### 输出格式

输出一个整数，表示从1号点到n号点的最多经过k条边的最短距离。
如果不存在满足条件的路径，则输出“impossible”。

### 数据范围
```java
1≤n,k≤5001≤n,k≤500,
1≤m≤100001≤m≤10000,
任意边长的绝对值不超过10000。
```
### 输入样例

```java
3 3 1
1 2 1
2 3 1
1 3 3
```

### 输出样例

```java
3
```

### 参考代码

```java
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std ;

const int N = 510 , M = 10010;
int n , m , k;
int dist[N],backup[N];    //backup  备份dist数组
struct Edge{
    int a ,b ,w;
}edges[M];

int bellman_ford(){
    //       -2
    //  1   ---->    n
    // +∞            +∞
    memset(dist , 0x3f , sizeof dist);
    dist[1] = 0 ;
    for(int i = 0 ; i < k ; i++){
        memcpy(backup,dist,sizeof dist);
        for(int j = 0 ; j < m ; ++j){
            int a = edges[j].a, b = edges[j].b , w = edges[j].w;
            dist[b] = min(dist[b],backup[a]+w);
        }
    }

    if(dist[n] > 0x3f3f3f3f /2 )  return -10000;
    return dist[n];
}
int main(int argc, char const *argv[])
{
    cin >> n >> m >> k ;
    int i = 0 ;
    for(int i = 0 ; i < m  ; ++i){
        cin >> edges[i].a >> edges[i].b >> edges[i].w ;
    }
    
    int ans = bellman_ford();
    if(ans == -10000) puts("impossible");
    else          cout << ans <<endl;             
    return 0;
}
```

>>>>>>> 725fcb7a857252b3986fe8e21eadbeb0e3e3ddc6
