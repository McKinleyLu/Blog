<<<<<<< HEAD
<<<<<<< HEAD
---
title: 图像渲染
toc: true
cover: /img/4.jpg
categories:
  - 竞赛
tags:
  - leetcode
abbrlink: 4265
date: 2021-07-17 07:42:54
---

### 题目描述

有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。<!-- more -->

给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。

为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。

最后返回经过上色渲染后的图像。

#### 示例

```
输入: 
image = [[1,1,1],[1,1,0],[1,0,1]]
sr = 1, sc = 1, newColor = 2
输出: [[2,2,2],[2,2,0],[2,0,1]]
解析: 
在图像的正中间，(坐标(sr,sc)=(1,1)),
在路径上所有符合条件的像素点的颜色都被更改成2。
注意，右下角的像素没有更改为2，
因为它不是在上下左右四个方向上与初始点相连的像素点。
```

### 分析

这是一道简单的队列BFS题

1. 注意，两个点不仅要相邻，而且要初始像素相同
2. 如果以前的颜色与新的颜色一样，就不用改变，直接返回old
3. 本题示例描述不清(自认为),看看参考代码会更好理解

### 参考代码

```java
class Solution {
public:
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {
        int row = image.size();
        int col = image[0].size();
        vector<pair<int,int>> directions = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };
        queue<pair<int,int>> q ;
        int old = image[sr][sc];
        if(image[sr][sc] == newColor)
        {
        	return image;
        }
        //BFS
        
        q.push({sr,sc});
        while(!q.empty())
        {
        	int len = q.size();
        	while(len--)
          {
          	pair<int,int> olds = q.front();
        	int rows = olds.first;
        	int cols = olds.second;
        	q.pop();
        	image[rows][cols] = newColor;
        	for(int i = 0 ; i < 4 ; ++i)
        	{
        		int tempr = rows + directions[i].first;
        		int tempc = cols + directions[i].second;
        		if(tempr >= 0 && tempr < image.size() &&  tempc >= 0 && tempc < image[0].size() && image[tempr][tempc] != newColor && image[tempr][tempc] == old)
        		{
        			q.push({tempr,tempc});
        		}
        	}
          }

        }
        return image ;
    }
};
```

=======
---
title: 图像渲染
toc: true
cover: /img/4.jpg
categories:
  - 竞赛
tags:
  - leetcode
abbrlink: 4265
date: 2021-07-17 07:42:54
---

### 题目描述

有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。<!-- more -->

给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。

为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。

最后返回经过上色渲染后的图像。

#### 示例

```
输入: 
image = [[1,1,1],[1,1,0],[1,0,1]]
sr = 1, sc = 1, newColor = 2
输出: [[2,2,2],[2,2,0],[2,0,1]]
解析: 
在图像的正中间，(坐标(sr,sc)=(1,1)),
在路径上所有符合条件的像素点的颜色都被更改成2。
注意，右下角的像素没有更改为2，
因为它不是在上下左右四个方向上与初始点相连的像素点。
```

### 分析

这是一道简单的队列BFS题

1. 注意，两个点不仅要相邻，而且要初始像素相同
2. 如果以前的颜色与新的颜色一样，就不用改变，直接返回old
3. 本题示例描述不清(自认为),看看参考代码会更好理解

### 参考代码

```java
class Solution {
public:
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {
        int row = image.size();
        int col = image[0].size();
        vector<pair<int,int>> directions = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };
        queue<pair<int,int>> q ;
        int old = image[sr][sc];
        if(image[sr][sc] == newColor)
        {
        	return image;
        }
        //BFS
        
        q.push({sr,sc});
        while(!q.empty())
        {
        	int len = q.size();
        	while(len--)
          {
          	pair<int,int> olds = q.front();
        	int rows = olds.first;
        	int cols = olds.second;
        	q.pop();
        	image[rows][cols] = newColor;
        	for(int i = 0 ; i < 4 ; ++i)
        	{
        		int tempr = rows + directions[i].first;
        		int tempc = cols + directions[i].second;
        		if(tempr >= 0 && tempr < image.size() &&  tempc >= 0 && tempc < image[0].size() && image[tempr][tempc] != newColor && image[tempr][tempc] == old)
        		{
        			q.push({tempr,tempc});
        		}
        	}
          }

        }
        return image ;
    }
};
```

>>>>>>> 725fcb7a857252b3986fe8e21eadbeb0e3e3ddc6
=======
---
title: 图像渲染
toc: true
cover: /img/4.jpg
categories:
  - 竞赛
tags:
  - leetcode
abbrlink: 4265
date: 2021-07-17 07:42:54
---

### 题目描述

有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。<!-- more -->

给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。

为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。

最后返回经过上色渲染后的图像。

#### 示例

```
输入: 
image = [[1,1,1],[1,1,0],[1,0,1]]
sr = 1, sc = 1, newColor = 2
输出: [[2,2,2],[2,2,0],[2,0,1]]
解析: 
在图像的正中间，(坐标(sr,sc)=(1,1)),
在路径上所有符合条件的像素点的颜色都被更改成2。
注意，右下角的像素没有更改为2，
因为它不是在上下左右四个方向上与初始点相连的像素点。
```

### 分析

这是一道简单的队列BFS题

1. 注意，两个点不仅要相邻，而且要初始像素相同
2. 如果以前的颜色与新的颜色一样，就不用改变，直接返回old
3. 本题示例描述不清(自认为),看看参考代码会更好理解

### 参考代码

```java
class Solution {
public:
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {
        int row = image.size();
        int col = image[0].size();
        vector<pair<int,int>> directions = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };
        queue<pair<int,int>> q ;
        int old = image[sr][sc];
        if(image[sr][sc] == newColor)
        {
        	return image;
        }
        //BFS
        
        q.push({sr,sc});
        while(!q.empty())
        {
        	int len = q.size();
        	while(len--)
          {
          	pair<int,int> olds = q.front();
        	int rows = olds.first;
        	int cols = olds.second;
        	q.pop();
        	image[rows][cols] = newColor;
        	for(int i = 0 ; i < 4 ; ++i)
        	{
        		int tempr = rows + directions[i].first;
        		int tempc = cols + directions[i].second;
        		if(tempr >= 0 && tempr < image.size() &&  tempc >= 0 && tempc < image[0].size() && image[tempr][tempc] != newColor && image[tempr][tempc] == old)
        		{
        			q.push({tempr,tempc});
        		}
        	}
          }

        }
        return image ;
    }
};
```

>>>>>>> 725fcb7a857252b3986fe8e21eadbeb0e3e3ddc6
