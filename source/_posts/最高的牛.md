---
title: 最高的牛
toc: true
cover: /img/4.jpg
categories:
  - 算法
  - 算法进阶指南
tags:
  - 差分
  - C++
  - 算法-简单级
abbrlink: 60751
date: 2021-10-10 17:34:41
---

### 题目表述

有 N 头牛站成一行，被编队为 1、2、3…N每头牛的身高都为整数。<!-- more -->

当且仅当两头牛中间的牛身高都比它们矮时，两头牛方可看到对方。

现在，我们只知道其中最高的牛是第 P 头，它的身高是 H ，剩余牛的身高未知。

但是，我们还知道这群牛之中存在着 M 对关系，每对关系都指明了某两头牛 A 和 B 可以相互看见。

求每头牛的身高的最大可能值是多少。

#### 输入格式

第一行输入整数 N,P,H,M，数据用空格隔开。

接下来 M 行，每行输出两个整数 A 和 B ，代表牛 A 和牛 B 可以相互看见，数据用空格隔开。

#### 输出格式

一共输出 N 行数据，每行输出一个整数。

第 i 行输出的整数代表第i头牛可能的最大身高。

#### 数据范围

1≤N≤10000
1≤H≤1000000
1≤A,B≤10000
0≤M≤10000

#### 输入样例：

```
9 3 5 5
1 3
5 3
4 3
3 7
9 8
```

#### 输出样例：

```
5
4
5
3
4
4
5
5
5
```

##### 注意：

- 此题中给出的关系对可能存在重复

### 思路

此题比较简单，通过思考容易知道，两头互相可以看到的牛之间的牛，要比这边界的两头牛身高要小，

我们不妨先假设b[1] = h ,  b[i] = 0 (i = 2 ,3 ,...,n) ,这样所有牛刚开始身高一样，然后每一对可以看见的牛之间身高减一即可，这里使用了[IncDec序列中的知识点](https://www.mckinleylu.com/2021/10/10/incdec-xu-lie/)： 对于[L,R]区间数组值全部减一，使得b[L] -- ,b[R+1]++即可.

另外注意使用C++的set种的count方法，可以实现去重

### 参考代码

方法一：  使用非差分法 ，时间复杂度为O(n^2)

```c++
/**
 * @file 12.cpp
 * @author your name (you@domain.com)
 * @brief 
 * @version 0.1
 * @date 2021-10-10
 * 
 * @copyright Copyright (c) 2021
 * 
 *   首先假设所有牛都和最高的牛身高一样
 *   然后，两个牛可以看见的中间牛，身高统一减一即可
 *   
 *   自己写本题时，未考虑到使用差分    
 *   差分 即 假设对[l,r]区间内所有数字加 1，则有 
 *   b[l+1]++  b[r+1] --  
 *   a[1] = b[1]
 *   a[i] = b[1] + b[2] + ... +b[i]
 * 
 *  对于本题，需要进行排重，即(3,7) 和 (7,3)是一个性质
 */
#include<iostream>
#include<cstring>
#include<set>
using namespace std;
const int N = 10005;
int  a[N];
int main(){
    int n ,p,h,m;
    cin >> n >> p >> h >> m;
    set<pair<int,int>>s;
    for(int i = 1 ; i<= n ; ++i) a[i] = h;
    for(int i = 1 ,x,y; i <= m ; ++i){
        cin >> x >> y;
        if(!s.count({x,y})){
            s.insert({x,y});
            int l = min(x,y) , r = max(x,y);
            for(int k  = l + 1; k < r ; ++k)  {a[k]--;}
        }
        
    } 
    for(int i = 1 ; i<= n ; ++i) { cout<<a[i]<<endl;}
    return 0 ;
}
```

方法二：使用差分法，时间复杂度为O(N)

```c++
#include <iostream>
#include <algorithm>
#include <set>

using namespace std;

const int N = 10010;

int d[N];

int main()
{
    int n, p, h, m;
    set<pair<int, int>> existed;
    cin >> n >> p >> h >> m;
    d[1] = h;
    for (int i = 0, a, b; i < m; i ++ )
    {
        cin >> a >> b;
        if (a > b) swap(a, b);
        if (!existed.count({a, b}))
        {
            existed.insert({a, b});
            d[a + 1] --, d[b] ++ ;
        }
    }

    for (int i = 1; i <= n; i ++ )
    {
        d[i] += d[i - 1];
        cout << d[i] << endl;
    }
    return 0;
}
```

