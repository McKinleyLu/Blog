---
title: 区间合并
categories:
  - 基础算法
  - 竞赛
  - 竞赛模板
tags:
  - 区间合并
  - c++
abbrlink: 6974
date: 2021-10-21 19:37:56
---

### 区间合并

快速的把n个有交集的区间进行合并。<!-- more -->

如下图所示，最终黑色的几个区间，合成了两个绿色的区间

![picture](/img/jcsf7.jpg)

### 合并方法

* 首先按照区间左端点排序
* 两个区间有三种关系，如下图四个线段表示，第一个线段为原线段

![picture](/img/jcsf8.jpg)

### 代码思路

首先设置两个边界区间，st  = -(1e5+10)  , ed = -(1e5+10)

接下来我们在循环中依次判断三种情况：

* 如果无法合并，则把第一个区间(前面的区间，不是当前区间)加入到ans中，同时维护第二个区间(当前区间)，将它的区间边界赋值给`st`和`ed`(注意，初始的-1e5区间不可以进入哦）
* 如果可以合并，即第二个区间在第一个区间内部，或者第二个区间和第一个区间有交集，则进入else合并
* 循环最后还剩着第二个区间没有加入到ans中m,最后加入一下即可(此条结合第一条看即可)

### 参考代码

```java
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std ;
typedef pair<int,int> PII;
const int N  =  1e5 + 10 ;
vector<PII> eg , ans;

int merge(vector<PII> &eg){
    if(eg.size() == 0 )  return 0 ;
    if(eg.size() == 1 )  return 1 ;
    int st = -N , ed = -N ;
    for(int i = 1 ; i < eg.size() ; ++i){
        if(ed < eg[i].first){
            if(eg[i].first != -N)  ans.push_back({st,ed});
            st = eg[i].first , ed = eg[i].second;
        }
        else   ed = max(ed,eg[i].second);
    }
    return ans.size();
}


int main(){
  int n ;
  cin >> n ;
  for(int i = 1,st,ed ; i <= n ; ++i){
      cin >> st >> ed ;
      eg.push_back({st,ed});
  }
  cout<<merge(eg)<<endl;
  return 0 ;
}

```

