---
title: 高精度运算
categories:
  - 基础算法
  - 竞赛
  - 竞赛模板
tags:
  - 高精度
  - c++
abbrlink: 3592
date: 2021-10-19 21:01:49
---

## 高精度运算

### 高精度加法

#### 存储

大整数存储，使用`string`输入，并使用数组存储`逆序`存储每一位<!-- more -->

#### 运算方法

按照普通加法计算步骤即可，A + B  + C(进位) 相加，  保存C1(C1代表进位)

![picture](/img/jcsf1.jpg)

#### 代码模板

```c++
vector<int> add(vector<int>&A , vector<int> B){
    vector<int> c ;
    int t = 0 ;  
    for(int i = 0 ;  i< A.size() || i < B.size() ; i++){
        if(i < A.size())  t += A[i];
        if(i < B.size())  t += B[i];
        C.push_back(t % 10);
        t /= 10 ;              //是否有进位
    }
    
    if(t) C.push_back(t);      //如果两数相加出现进位，最后补上进位即可
}


int main(){
    string a , b;
    vector<int>  A , B;
    
    cin >> a >> b;
    for(int i = a.size() - 1 ; i >= 0 ; i--) A.push_back(a[i] - '0');
    for(int i = b.size() - 1 ; i >= 0 ; i--) B.push_back(b[i] - '0');
}
```

### 高精度减法

#### 存储

同高精度加法一样

#### 运算方法

注意，如果是A - B 并且 A < B,  采用 `- (B - A)`，永远保证大数减去小数

![picture](/img/jcsf2.jpg)

#### 代码模板

```c++
// 判断是否有 A >= B
bool cmp(vector<int>&A ,vetctor<int>& B){
    if(A.size() != B.size())  return A.size() > B.size();
    for(int i = A.size() - 1 ; i >= 0 ; i --){
        if(A[i] != B[i]){
            return A[i] > B[i];
        }
    }
    return true ;   // A == B
}

// C = A - B 
vector<int> sub(vector<int>&A ,vetctor<int>& B){   //这里默认是A 必然大于 B 
    vector<int> c ;
    for(int i = 0 , t = 0; i < A.size() ; i++){
        t = A[i] - t ;
        if(i < B.size()) t -= B[i] ;      // 这两句其实为 A[i] - B[i] - 后一位进位
        
        C.push_back((t + 10 ) % 10) ;     //如果 t >= 0 则 t % 10 = t , 否则 t % 10 = 10 - t  
                                          //此句话完成了A - B的两种处理情况
        
        if(t < 0 ) t = 1 ;
        else       t = 0 ;
    }
    while(C.size() > 1  && C.back() == 0)  C.pop_back();
}


int main(){
    string a , b;
    vector<int>  A , B , c;
    
    cin >> a >> b;
    for(int i = a.size() - 1 ; i >= 0 ; i--) A.push_back(a[i] - '0');
    for(int i = b.size() - 1 ; i >= 0 ; i--) B.push_back(b[i] - '0');
    
    if(cmp(A,B)){
        for(int i = 0 ; i < c.size() ; ++i)  printf("%d",c.at(i));
    }
    else{
        printf("-");
        for(int i = 0 ; i < c.size() ; ++i)  printf("%d",c.at(i));
    }
}
```

### 高精度乘法

一个位数很长的数(6位+)，乘一个位数较小的(如4位)

#### 存储

同高精度加法一样

#### 运算方法

大数的每一位乘上小数，取模得实际位数，做除法得到进位

![picture](/img/jcsf3.jpg)

#### 代码模板

```c++
vector<int> mul(vector<int>A , int b){
    
    vector<int>  c ;
    int t = 0 ;
    for(int i = 0 ; i <= A.size() || t  ; ++i){
         if(i < A.size()) t += A[i] * b ;
         C.push_back(t / 10);
         t %= 10;       
    }
    return c ;
}

int main(){
    string a ;
    int b ;
    
    vector<int>  A ;
    for(int i = a.size() - 1 ; i >= 0 ; i--) A.push_back(a[i] - '0');
    
    auto c = mul(A,b);
    
    for(int i = C.size() - 1 ; i >= 0 ; i --)  printf("%d",C[i])
}
```

### 高精度除法

一个位数很长的数(6位+)，乘一个位数较小的(如4位)

#### 存储

同高精度加法一样

### 思想

假如一个数是A4A3A2A1，它除以b，那么可以如此运算：

* 首先令 r1 =  A4, 则商是   c1  =  r1  / b   余数是  c2  = r1 % b * 10
* 如此运算，知道这个数字每一位被运算完成
* 最后把商数组进行反转，去掉数字前的0即可

### 代码模板

```c++
// 计算A / b   商是C，余数是r
vector<int> div(vector<int>A , int b , int & r){
    
    vector<int>  c ;
    int r = 0 ;
    for(int i = A.size() -1 ; i >= 0 ; ++i){
        r =  r*10 + A[i] ;
        c.push_back( r / b );
        r  = r % b ;
    }
    
    reverse(c.begin(),c.end());
    while(c.size() > 1 && c.back() == 0) c.pop_back();
    return c ;
}

int main(){
    string a ;
    int b ;
    
    vector<int>  A ;
    for(int i = a.size() - 1 ; i >= 0 ; i--) A.push_back(a[i] - '0');
    
    int r ;
    auto c = div(A,b,r);
    
    for(int i = C.size() - 1 ; i >= 0 ; i --)  printf("%d",C[i])
    cout<<endl<<r<<endl;
}
```

