---
title: 递归实现排列型枚举
cover: /img/5.jpg
categories:
  - 算法
  - 算法进阶指南
tags:
  - 递归
  - 位运算
  - C++
  - 算法-简单级
abbrlink: 54185
date: 2021-10-05 18:32:31
---

把 1∼n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。<!-- more -->

#### 输入格式

一个整数 n。

#### 输出格式

按照从小到大的顺序输出所有方案，每行 1 个。

首先，同一行相邻两个数用一个空格隔开。

其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。

#### 数据范围

1≤n≤9

#### 输入样例：

```
3
```

#### 输出样例：

```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

### 题解

此题可以采用循环 + 递归技术，每一层递归向 向量中加入一个数字，且保证每一个分支问题数字排列循序不同。

由于状态压缩不能只能记录存在与不存在，而不能记录顺序，故应该采用向量保存数字

使用state保存所有数字是否加入向量

注意每一个子问题内容一致，所以处理完一个子分支是，要恢复现场。

### 参考代码

```c++
/**
 * @file 6.cpp
 * @author your name (you@domain.com)
 * @brief 
 * @version 0.1
 * @date 2021-10-05
 * @copyright Copyright (c) 2021
 *   经典的dfs 
 *   排列
 *   n个坑，从第一坑开始放数，接下来的坑选择没有·放过的书
 *   不用二进制数，因为二进制数只能表示存不存在，不能记录顺序,因此使用vector保存
 */
#include<iostream>
#include<vector>
using namespace std;
int n ;
vector<int> path;
void  dfs(int u , int state){
   if(u == n){     // 当 u == n 时，表示已经枚举完
       for(auto x : path) cout << x << " ";
       cout << endl;
       return ;
   }
   for(int i = 0 ; i < n ; i++){
       if(!(state >> i & 1)){     //判断数字是否已经加入到其中
           path.push_back(i + 1 );
           dfs(u + 1, state | (1 << i));   // 把第i位置成1
           // 恢复现场，保证子分支内容一致
           path.pop_back();
       }
   } 
}
int main(){
    cin >> n;
    dfs(0,0);  // 第一个数是指从哪里开始枚举，第二个数表示哪个数字已经被枚举过，因此第二个数可以用二进制数
    return 0;
}
```

