---
title: 最大层内元素之和
toc: true
cover: /img/4.jpg
categories:
  - 竞赛
tags:
  - leetcode
abbrlink: 7752
date: 2021-07-17 07:31:14
---

### 题目描述

给你一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推。
请你找出层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。<!-- more -->

#### 示例

![img](/img/leetcode1502.jpg)

```
输入：[1,7,0,7,-8,null,null]
输出：2
解释：
第 1 层各元素之和为 1，
第 2 层各元素之和为 7 + 0 = 7，
第 3 层各元素之和为 7 + -8 = -1，
所以我们返回第 2 层的层号，它的层内元素之和最大。
```

### 分析

这是一个典型的树与BFS综合题。通过计算树的每一层节点之和，方可回答此题。
此题涉及到了队列的BFS。
队列的作用是不仅要用于计算出当前层的节点值的和，还要保存本层节点孩子的地址。
通过while()循环，算出一层的值。

### 参考代码

```java
class Solution {
public:
    int maxLevelSum(TreeNode* root) {

        if(root == nullptr) {return 0;}
        //
        int maxlevel = 1 , curlevel = 1 , summax = 1 ;
        queue<TreeNode*> q ;
        q.push(root);
        while(!q.empty())
        {
            int s = q.size();
            int cursum = 0;
            while(s)
            {
                TreeNode* font = q.front();
                q.pop();
                if(font->left != nullptr){q.push(font->left);}
                if(font->right != nullptr){q.push(font->right);}
                cursum += font->val;
                --s;
            }
            if(cursum > summax){maxlevel = curlevel ; summax = cursum ; }
            ++curlevel;
        }
        return maxlevel;
    }
};
```

