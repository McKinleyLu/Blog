---
title: 归并排序
categories:
  - 基础算法
tags:
  - 归并排序
  - week1
abbrlink: 63711
date: 2021-10-18 20:22:09
---

### 归并排序

稳定算法

[可用于计算逆序数]()

### 主要思想

* 确定边界点 mid = (l+r) >> 1<!-- more -->
* 递归排序两个区间
* 最后归并两个已经排好序的区间 ， 合二为一

### 合二为一方法

* 设置两个指针，第一个指针指向第一个序列的首地址，第二个指针指向第二个序列的首地址
* 再开一个数组res
* 比较两个指针所指向的元素大小，如果第一个指针指向的元素更小，则把元素更小的元素放入res中，同时该元素指针加一
* 如果两个指针指向元素值相同，则把哪个元素放入res中都可以
* 最后把没有放入res数组中的元素按照顺序放入res数组中即可

### 时间复杂度

一共是log<sub>2<sub>n 层，每一层的最后合并复杂度是O(n)，所以时间复杂度是O( n * log<sub>2<sub>n)

### 参考代码

```java
int a[N] , temp[N];
merge_sort(int a[] , int l , int r){
    if( l >= r)  return ;    // 如果只剩一个数或者没有数，无需排序
     
     int mid = (l + r) >> 1 ;
     
     merge_sort(a,l,mid);
     merge_sort(a,mid+1,r);
     
     int k = 0 , i = l , j = mid + 1 ;   // 一定注意j的取值
     
     while(i <= mid && j <= r){          // 注意是 j <= r
          if(a[i] <= a[j])  temp[k++] = a[i++];
          else              temp[k++] = a[j++];
     }
     
     while(i <= mid)        temp[k++] = a[i++];
     while(j <= r)          temp[k++] = a[i++];
     
     for(int i = l ; ,k = 0 ; i <= r ; ++i,++k) a[i] = temp[k];   //注意此步，i = l 而不是 i = 0
}
```





