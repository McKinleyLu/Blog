<<<<<<< HEAD
<<<<<<< HEAD
---
title: 递归实现组合型枚举
toc: true
cover: /img/7.jpg
categories:
  - 基础算法
tags:
  - 递归
  - 位运算
abbrlink: 46373
date: 2021-10-06 22:33:43
---

从 1∼n这 n个整数中随机选出 m 个，输出所有可能的选择方案。<!-- more -->

#### 输入格式

两个整数 n,m 在同一行用空格隔开。

#### 输出格式

按照从小到大的顺序输出所有方案，每行 1 个。

首先，同一行内的数升序排列，相邻两个数用一个空格隔开。

其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 `1 3 5 7` 排在 `1 3 6 8` 前面）。

#### 数据范围

n>0 ,
0≤m≤n ,
n+(n−m)≤25

#### 输入样例：

```
5 3
```

#### 输出样例：

```
1 2 3 
1 2 4 
1 2 5 
1 3 4 
1 3 5 
1 4 5 
2 3 4 
2 3 5 
2 4 5 
3 4 5 
```

### 题解

通过观察题目，不难发现可以使用递归实现组合，具体实现方法如下：

1. 首先，每个数字都有出现与不出现两种情况，因此使用位运算+状态压缩

2. 其次，每次有且只有m个数字出现，因此递归层数 u = m

3. 由于要讨论0 - n这n个数，哪些数字要出现，因此需要循环

   * 每一层设置循环，一一枚举数字将未加入状态的数字逐个枚举加入

   * 通过思考  如果state =  00010 ,则下一个数字必须为第5-3位，选择一个，否则会出现重复，若选择第三位

     则state = 00110，下一个数字必须是5-4位中选一个，选三个即可

4. dfs(u,state,i)三个参数，其中u记录递归层数、state记录数字选择状态，而i代表下一层循环开始枚举的位数必须大于大于等于i，以防止踹出现重复排列

### 参考代码

```java
#include<iostream>
using namespace std;
int  n , m;
void dfs(int u,int state,int start){
    if(u == m){
        for(int i = 0 ; i < n; ++i){
            if(state >> i & 1){
                cout << i + 1 << " ";
            }
        }
        cout<<endl;
    }
    for(int i = start ; i < n ; ++i){
        //加入与不加入
        if(!(state >> i & 1))
            dfs(u + 1 , state | 1 << i,i);
    }

}
int main(){
    cin >> n >> m;
    dfs(0,0,0);    
    return 0 ;
}
```

=======
---
title: 递归实现组合型枚举
toc: true
cover: /img/7.jpg
categories:
  - 基础算法
tags:
  - 递归
  - 位运算
abbrlink: 46373
date: 2021-10-06 22:33:43
---

从 1∼n这 n个整数中随机选出 m 个，输出所有可能的选择方案。<!-- more -->

#### 输入格式

两个整数 n,m 在同一行用空格隔开。

#### 输出格式

按照从小到大的顺序输出所有方案，每行 1 个。

首先，同一行内的数升序排列，相邻两个数用一个空格隔开。

其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 `1 3 5 7` 排在 `1 3 6 8` 前面）。

#### 数据范围

n>0 ,
0≤m≤n ,
n+(n−m)≤25

#### 输入样例：

```
5 3
```

#### 输出样例：

```
1 2 3 
1 2 4 
1 2 5 
1 3 4 
1 3 5 
1 4 5 
2 3 4 
2 3 5 
2 4 5 
3 4 5 
```

### 题解

通过观察题目，不难发现可以使用递归实现组合，具体实现方法如下：

1. 首先，每个数字都有出现与不出现两种情况，因此使用位运算+状态压缩

2. 其次，每次有且只有m个数字出现，因此递归层数 u = m

3. 由于要讨论0 - n这n个数，哪些数字要出现，因此需要循环

   * 每一层设置循环，一一枚举数字将未加入状态的数字逐个枚举加入

   * 通过思考  如果state =  00010 ,则下一个数字必须为第5-3位，选择一个，否则会出现重复，若选择第三位

     则state = 00110，下一个数字必须是5-4位中选一个，选三个即可

4. dfs(u,state,i)三个参数，其中u记录递归层数、state记录数字选择状态，而i代表下一层循环开始枚举的位数必须大于大于等于i，以防止踹出现重复排列

### 参考代码

```java
#include<iostream>
using namespace std;
int  n , m;
void dfs(int u,int state,int start){
    if(u == m){
        for(int i = 0 ; i < n; ++i){
            if(state >> i & 1){
                cout << i + 1 << " ";
            }
        }
        cout<<endl;
    }
    for(int i = start ; i < n ; ++i){
        //加入与不加入
        if(!(state >> i & 1))
            dfs(u + 1 , state | 1 << i,i);
    }

}
int main(){
    cin >> n >> m;
    dfs(0,0,0);    
    return 0 ;
}
```

>>>>>>> 725fcb7a857252b3986fe8e21eadbeb0e3e3ddc6
=======
---
title: 递归实现组合型枚举
toc: true
cover: /img/7.jpg
categories:
  - 基础算法
tags:
  - 递归
  - 位运算
abbrlink: 46373
date: 2021-10-06 22:33:43
---

从 1∼n这 n个整数中随机选出 m 个，输出所有可能的选择方案。<!-- more -->

#### 输入格式

两个整数 n,m 在同一行用空格隔开。

#### 输出格式

按照从小到大的顺序输出所有方案，每行 1 个。

首先，同一行内的数升序排列，相邻两个数用一个空格隔开。

其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 `1 3 5 7` 排在 `1 3 6 8` 前面）。

#### 数据范围

n>0 ,
0≤m≤n ,
n+(n−m)≤25

#### 输入样例：

```
5 3
```

#### 输出样例：

```
1 2 3 
1 2 4 
1 2 5 
1 3 4 
1 3 5 
1 4 5 
2 3 4 
2 3 5 
2 4 5 
3 4 5 
```

### 题解

通过观察题目，不难发现可以使用递归实现组合，具体实现方法如下：

1. 首先，每个数字都有出现与不出现两种情况，因此使用位运算+状态压缩

2. 其次，每次有且只有m个数字出现，因此递归层数 u = m

3. 由于要讨论0 - n这n个数，哪些数字要出现，因此需要循环

   * 每一层设置循环，一一枚举数字将未加入状态的数字逐个枚举加入

   * 通过思考  如果state =  00010 ,则下一个数字必须为第5-3位，选择一个，否则会出现重复，若选择第三位

     则state = 00110，下一个数字必须是5-4位中选一个，选三个即可

4. dfs(u,state,i)三个参数，其中u记录递归层数、state记录数字选择状态，而i代表下一层循环开始枚举的位数必须大于大于等于i，以防止踹出现重复排列

### 参考代码

```java
#include<iostream>
using namespace std;
int  n , m;
void dfs(int u,int state,int start){
    if(u == m){
        for(int i = 0 ; i < n; ++i){
            if(state >> i & 1){
                cout << i + 1 << " ";
            }
        }
        cout<<endl;
    }
    for(int i = start ; i < n ; ++i){
        //加入与不加入
        if(!(state >> i & 1))
            dfs(u + 1 , state | 1 << i,i);
    }

}
int main(){
    cin >> n >> m;
    dfs(0,0,0);    
    return 0 ;
}
```

>>>>>>> 725fcb7a857252b3986fe8e21eadbeb0e3e3ddc6
