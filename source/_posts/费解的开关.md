---
title: 费解的开关
toc: true
cover: /img/6.jpg
categories:
   - 算法进阶指南
tags:
  - 枚举
  - 位运算
abbrlink: 52108
date: 2021-10-06 22:44:37
---

### 题目描述

你玩过“拉灯”游戏吗？  <!-- more -->

25盏灯排成一个 5×5的方形。

每一个灯都有一个开关，游戏者可以改变它的状态。

每一步，游戏者可以改变某一个灯的状态。

游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。

我们用数字 1表示一盏开着的灯，用数字 0 表示关着的灯。

下面这种状态

```
10111
01101
10111
10000
11011
```

在改变了最左上角的灯的状态后将变成：

```
01111
11101
10111
10000
11011
```

再改变它正中间的灯后状态将变成：

```
01111
11001
11001
10100
11011
```

给定一些游戏的初始状态，编写程序判断游戏者是否可能在 66 步以内使所有的灯都变亮。

#### 输入格式

第一行输入正整数 n，代表数据中共有 n 个待解决的游戏初始状态。

以下若干行数据分为 n 组，每组数据有 5 行，每行 5 个字符。

每组数据描述了一个游戏的初始状态。

各组数据间用一个空行分隔。

#### 输出格式

一共输出 n 行数据，每行有一个小于等于 6 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。

对于某一个游戏初始状态，若 6 步以内无法使所有灯变亮，则输出 −1。

#### 数据范围

0<n≤5000

#### 输入样例：

```
3
00111
01011
10001
11010
11100

11101
11101
11110
11111
11111

01111
11111
11111
11111
11111
```

#### 输出样例：

```
3
2
-1
```

### 题解

1. 通过观察发现，如果第一行的灯亮暗确定，后面的结果确定

2. 第i层按与不按，要看第i-1层，通过按与不按，使得i-1层灯全部点亮

3. 当完成第四层灯的按与不按后，如果第五层不全亮，证明第一行枚举的情况失败，如果调灯大于6次，也是失败的

   通过枚举第一层所有灯的开与不开，选取最小的调灯次数。

4. 如果最后最小调灯次数大于6，或者所有第一行调灯方法都无法使得25盏灯全亮，则返回-1，否则返回最小调灯数

### 参考代码

```java
/**
 * @file 8.cpp
 * @author your name (you@domain.com)
 * @brief 
 * @version 0.1
 * @date 2021-10-06
 * 
 * @copyright Copyright (c) 2021
 * 
 */
#include<iostream>
#include<cstring>
using namespace std;
int n ;
const int N = 10;
char g[N][N];
int xz[5] = {0,-1,1,0,0} , yz[5] = {0,0,0,1,-1};     //技巧，顺序为 中 左 右 上 下

void turn(int x , int y){
    for(int i = 0 ; i < 5 ; ++i){
        int a = x + xz[i] , b =  y + yz[i];
        if(a >= 0 && a < 5 && b >= 0  && b < 5){
            g[a][b] ^= 1;
        }
    }
}
void work(){
    int ans = 100000;
    for(int k = 0; k < 1 << 5 ; ++k){                    //第一行5盏灯，一共1 << 5 = 2^5 = 32种枚举情况
        int count = 0;
        char temp[N][N];
        memcpy(temp,g,sizeof g);                         //将原本输入的灯亮情况，保存在temp，后续使用


        for(int i = 0 ; i < 5 ; ++i){
            if( k >> i & 1)   turn(0,i), count ++;
        }

        for(int i = 0 ; i < 4 ; ++i){
            for(int j = 0 ; j < 5 ; ++j){
                if(g[i][j] == '0')  turn(i+1,j),count++;
            }
        }

        bool isSuccess = true;
        for(int i  = 0 ; i < 5  ; ++i){
            if(g[4][i] == '0')  {isSuccess = false;break;}         //如果最后一行有灯没亮，则该枚举方案不正确
        }

        if(isSuccess)   ans = min(ans,count);                      //如果全部灯都亮，则保存最小的调灯次数
         memcpy(g,temp,sizeof g);
    }
    if(ans <= 6) cout<<ans<<endl;                                
    else         cout<<-1<<endl;
}
int main(){
    cin >> n ;
    while(n--){
        for(int i = 0 ; i < 5 ; ++i){cin >> g[i];}
        work();
    }   
    return 1;
}
```



