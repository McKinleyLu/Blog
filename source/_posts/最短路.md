---
title: 最短路
categories:
  - 基础算法
tags:
  - 最短路
  - week3
abbrlink: 19070
date: 2022-03-11 17:06:31
---
### 最短路
即求图中点与点之间的最短路径。
#### 最短路分类
1. 单源最短路径
   * 所有边权都是正数：朴素迪杰斯特拉O(V^2),堆优化版迪杰斯特拉O(ElogN)
   * 存在负边:Bellman-Ford算法O(VE),SPFA(一般是O(E)，最坏是O(VE))
2. 多源最短路: Floyd算法O(n^3)
3. 难点在于将问题抽象成最短路

#### 朴素迪杰斯特拉
1. 初始化距离  dist[源点] = 0 , dist[i] = +∞
2. 设置集合S，S中存放已经确定最短路的点
3. 使用for循环，其内找到不到S中且距离源点最近的点k，将该点加入S中，并更新源点到其他点的距离(源点->k->更新点)
4. 时间复杂度O(V*2)
5. 最短路如果出现重边，选择min边即可
6. [相关例题](https://www.mckinleylu.com/2022/03/11/dan-yuan-zui-duan-lu-po-su-di-jie-si-te-la/)
7. 模板

```java
int dijstra(){
    memset(dist,0x3f,sizeof dist);
    dist[1] = 0 ;

    for(int i = 1 ; i <= n ; i++){
        int t = - 1;  //找打未放入集合S的最小点
        for(int j = 1 ; j <= n; j++){
            if(!s[j] && (t == -1 || dist[t] > dist[j]))  t = j ;
        }
        s[t] = true;
        
        for(int j = 1 ; j <= n ; ++j){
            dist[j] = min(dist[j],dist[t] + g[t][j]);
        }
    }

   if(dist[n] == 0x3f3f3f3f)  return -1 ;
   else                       return dist[n];

}
```
#### 堆优化迪杰斯特拉
1. 朴素迪杰斯特拉的复杂度在于找最小距离
2. 我们可是使用堆来找最小距离，这样就是O(1),堆中修改一个数,时间复杂度是O(logn),由于有m条边，因此是O(m*logn)
3. 直接使用优先队列
4. [相关例题](https://www.mckinleylu.com/2022/03/11/dan-yuan-zui-duan-lu-po-su-di-jie-si-te-la/)
5. 模板

```java
int dijstra(){
    memset(dist,0x3f,sizeof dist);
    dist[1] = 0 ;

    priority_queue<PII,vector<PII>, greater<PII>> heap;
    heap.push({0,1});    // 距离是0，点的编号是1

    while(heap.size()){
        auto t = heap.top();
        heap.pop();

        int ver = t.second , distance = t.first;
        if(used[ver]) continue;

        for(int i = h[ver]; i != -1 ; i = ne[i]){
            int j = en[i]; 
            if(dist[j] > distance + w[i] ){
                  dist[j] = distance + w[i];
                  heap.push({dist[j],j});  
               }
        }
    }
    if(dist[n] == 0x3f3f3f3f)  return -1 ;
    return dist[n];
}
```
#### BellmanFord算法
1. 用于单源带负边权,迭代n次，每一次循环遍历所有边`(a,b,w)`,`dist[b] = min(dist[b],dist[a]+w);`类似于迪杰斯特拉。
2. 循环n次后，一定满足`dist[b] <= dist[a] + w`
3. 图中不得有负权回路
4. 这种方法可用于检验是否有负权回路
   * 当前    从源点经过不超过k条边的最短路距离
   * 如果第n次仍有更新，即存在一个最短路径，上面有n条边,可n条边对应n+1个边，因此必有负环
5. 题目中说不超过几条边，就是只迭代几次，
6. 设置`backup`备份`dist`数组，虽然更新一次，可能发生串联，backup使用上一次迭代的结果，就不会发生串联(指的是 a-b-c, a-b更新后，在一个循环内,a-c使用了a-b的值,不对，应该使用备份backup数组的未更新的a-b距离)
7. [相关例题](https://www.mckinleylu.com/2022/03/11/you-bian-shu-xian-zhi-de-zui-duan-lu/)
8. 模板
```java
int bellman_ford(){
    //       -2
    //  1   ---->    n
    // +∞            +∞
    memset(dist , 0x3f , sizeof dist);
    dist[1] = 0 ;
    for(int i = 0 ; i < k ; i++){
        memcpy(backup,dist,sizeof dist);
        for(int j = 0 ; j < m ; ++j){
            int a = edges[j].a, b = edges[j].b , w = edges[j].w;
            dist[b] = min(dist[b],backup[a]+w);
        }
    }

    if(dist[n] > 0x3f3f3f3f /2 )  return -10000;
    return dist[n];
}
```
#### spfa算法
1. 不得存在负环
2. 使用宽搜做优化
   * 源点放入队列
   * 在循环中弹出源点
   * 找到最小的边t,把t的后继节点加入队列中(也就是说，前面的点变小了，后面的点才有机会变小)
   * 重复,直到队列内元素个数为0
3. 对BellmanFord算法进行优化
4. 时间复杂度O(nm)
5. 网格结构可能会被卡住,使用迪杰斯特拉就行


#### spfa算法判断负环
使用抽屉原理
1. dist数组,当前源点到某一点最短距离

2. cnt数组,当前最短路边的数量

3. 更新方法
   ```java
   dist[x]  = dist[t] +  w[i];
   cnt[x]   = cnt[t]  + 1 ;
   ```
   
4. 当某一次,cnt数组中的元素，有一个值>=n,则路径上存在环

5. [相关例题1](https://www.mckinleylu.com/2022/03/11/spfa-pan-duan-fu-huan/)

6. [相关例题2](https://www.mckinleylu.com/2022/03/11/spfa-qiu-zui-duan-lu/)

6. 模板
```java
bool spfa(){
    memset(dist,0x3f,sizeof dist);
    dist[1] = 0 ;

    queue<int> q ;
    q.push(1);
    used[1] = true ;

    while(q.size()){
        int t = q.front() ;
        q.pop();

        used[t] = false;
        
        for(int i = h[t] ; i != -1 ; i = ne[i])
        {
              int j = en[i];
              if(dist[j] > dist[t] + w[i])
              {
                  dist[j] = dist[t] + w[i];
                  cnt[j] = cnt[t] + 1;
                  if(cnt[j] >= n) return false ;
                  if(!used[j]){
                      q.push(j);
                      used[j] = true ;
                  }
              }
        }

    }
    return true;
}
```