<<<<<<< HEAD
<<<<<<< HEAD
---
title: 迪杰斯特拉
categories:
  - 基础算法
tags:
  - 最短路
  - week3
abbrlink: 36415
date: 2022-03-11 17:07:53
---

### 题目描述

给定一个n个点m条边的有向图，图中可能存在重边和自环，所有边权均为正值。请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出-1。

### 输入格式

第一行包含整数n和m。
接下来m行每行包含三个整数x，y，z，表示点x和点y之间存在一条有向边，边长为z。

### 输出格式

输出一个整数，表示1号点到n号点的最短距离。
如果路径不存在，则输出-1。

### 数据范围
```java
1≤n≤500,
1≤m≤10^5,
图中涉及边长均不超过10000。
```

### 输入样例

```java
3 3
1 2 2
2 3 1
1 3 4
```

### 输出样例

```java
3
```

### 参考代码--朴素版

```java
#include <iostream>
#include <cstring>
using namespace std;
const int N = 510 ;
int n, m;
int g[N][N];
int dist[N];
bool s[N];
int dijstra(){
    memset(dist,0x3f,sizeof dist);
    dist[1] = 0 ;

    for(int i = 1 ; i <= n ; i++){
        int t = - 1;  //找打未放入集合S的最小点
        for(int j = 1 ; j <= n; j++){
            if(!s[j] && (t == -1 || dist[t] > dist[j]))  t = j ;
        }
        s[t] = true;
        
        for(int j = 1 ; j <= n ; ++j){
            dist[j] = min(dist[j],dist[t] + g[t][j]);
        }
    }

   if(dist[n] == 0x3f3f3f3f)  return -1 ;
   else                       return dist[n];

}
int main(int argc, char const *argv[])
{
    cin >> n >> m; 
    memset(g,0x3f,sizeof g);
    while(m--){
        int x ,y ,w ;
        cin >> x >> y >> w ;
        g[x][y] = min(g[x][y],w);
    }
   cout<< dijstra() <<endl;
    return 0;
}
```

### 参考代码--堆优化版

```java
#include <iostream>
#include <cstring>
#include <queue>
using namespace std;
typedef pair<int,int> PII;
const int N = 1e5 + 10;
int n , m ;
int h[N],en[N],ne[N],w[N],idx = 0 ;
int dist[N];
bool used[N];
void insert(int x ,int y ,int ww){
    en[idx] = y , ne[idx] = h[x] , w[idx] = ww , h[x] = idx++;
}
void init(){
    memset(h,-1,sizeof h );
}

int dijstra(){
    memset(dist,0x3f,sizeof dist);
    dist[1] = 0 ;

    priority_queue<PII,vector<PII>, greater<PII>> heap;
    heap.push({0,1});    // 距离是0，点的编号是1

    while(heap.size()){
        auto t = heap.top();
        heap.pop();

        int ver = t.second , distance = t.first;
        if(used[ver]) continue;

        for(int i = h[ver]; i != -1 ; i = ne[i]){
            int j = en[i]; 
            if(dist[j] > distance + w[i] ){
                  dist[j] = distance + w[i];
                  heap.push({dist[j],j});  
               }
        }
    }
    if(dist[n] == 0x3f3f3f3f)  return -1 ;
    return dist[n];
}

int main(int argc, char const *argv[])
{
    int n , m;
    cin >> n >> m;
    init();
    while(m--){
        int x , y , w ;
        cin >> x >> y >> w ;
        insert(x,y,w);
    }
    cout << dist[n] << endl;
    return 0;
}
```

=======
---
title: 迪杰斯特拉
categories:
  - 基础算法
tags:
  - 最短路
  - week3
abbrlink: 36415
date: 2022-03-11 17:07:53
---

### 题目描述

给定一个n个点m条边的有向图，图中可能存在重边和自环，所有边权均为正值。请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出-1。

### 输入格式

第一行包含整数n和m。
接下来m行每行包含三个整数x，y，z，表示点x和点y之间存在一条有向边，边长为z。

### 输出格式

输出一个整数，表示1号点到n号点的最短距离。
如果路径不存在，则输出-1。

### 数据范围
```java
1≤n≤500,
1≤m≤10^5,
图中涉及边长均不超过10000。
```

### 输入样例

```java
3 3
1 2 2
2 3 1
1 3 4
```

### 输出样例

```java
3
```

### 参考代码--朴素版

```java
#include <iostream>
#include <cstring>
using namespace std;
const int N = 510 ;
int n, m;
int g[N][N];
int dist[N];
bool s[N];
int dijstra(){
    memset(dist,0x3f,sizeof dist);
    dist[1] = 0 ;

    for(int i = 1 ; i <= n ; i++){
        int t = - 1;  //找打未放入集合S的最小点
        for(int j = 1 ; j <= n; j++){
            if(!s[j] && (t == -1 || dist[t] > dist[j]))  t = j ;
        }
        s[t] = true;
        
        for(int j = 1 ; j <= n ; ++j){
            dist[j] = min(dist[j],dist[t] + g[t][j]);
        }
    }

   if(dist[n] == 0x3f3f3f3f)  return -1 ;
   else                       return dist[n];

}
int main(int argc, char const *argv[])
{
    cin >> n >> m; 
    memset(g,0x3f,sizeof g);
    while(m--){
        int x ,y ,w ;
        cin >> x >> y >> w ;
        g[x][y] = min(g[x][y],w);
    }
   cout<< dijstra() <<endl;
    return 0;
}
```

### 参考代码--堆优化版

```java
#include <iostream>
#include <cstring>
#include <queue>
using namespace std;
typedef pair<int,int> PII;
const int N = 1e5 + 10;
int n , m ;
int h[N],en[N],ne[N],w[N],idx = 0 ;
int dist[N];
bool used[N];
void insert(int x ,int y ,int ww){
    en[idx] = y , ne[idx] = h[x] , w[idx] = ww , h[x] = idx++;
}
void init(){
    memset(h,-1,sizeof h );
}

int dijstra(){
    memset(dist,0x3f,sizeof dist);
    dist[1] = 0 ;

    priority_queue<PII,vector<PII>, greater<PII>> heap;
    heap.push({0,1});    // 距离是0，点的编号是1

    while(heap.size()){
        auto t = heap.top();
        heap.pop();

        int ver = t.second , distance = t.first;
        if(used[ver]) continue;

        for(int i = h[ver]; i != -1 ; i = ne[i]){
            int j = en[i]; 
            if(dist[j] > distance + w[i] ){
                  dist[j] = distance + w[i];
                  heap.push({dist[j],j});  
               }
        }
    }
    if(dist[n] == 0x3f3f3f3f)  return -1 ;
    return dist[n];
}

int main(int argc, char const *argv[])
{
    int n , m;
    cin >> n >> m;
    init();
    while(m--){
        int x , y , w ;
        cin >> x >> y >> w ;
        insert(x,y,w);
    }
    cout << dist[n] << endl;
    return 0;
}
```

>>>>>>> 725fcb7a857252b3986fe8e21eadbeb0e3e3ddc6
=======
---
title: 迪杰斯特拉
categories:
  - 基础算法
tags:
  - 最短路
  - week3
abbrlink: 36415
date: 2022-03-11 17:07:53
---

### 题目描述

给定一个n个点m条边的有向图，图中可能存在重边和自环，所有边权均为正值。请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出-1。

### 输入格式

第一行包含整数n和m。
接下来m行每行包含三个整数x，y，z，表示点x和点y之间存在一条有向边，边长为z。

### 输出格式

输出一个整数，表示1号点到n号点的最短距离。
如果路径不存在，则输出-1。

### 数据范围
```java
1≤n≤500,
1≤m≤10^5,
图中涉及边长均不超过10000。
```

### 输入样例

```java
3 3
1 2 2
2 3 1
1 3 4
```

### 输出样例

```java
3
```

### 参考代码--朴素版

```java
#include <iostream>
#include <cstring>
using namespace std;
const int N = 510 ;
int n, m;
int g[N][N];
int dist[N];
bool s[N];
int dijstra(){
    memset(dist,0x3f,sizeof dist);
    dist[1] = 0 ;

    for(int i = 1 ; i <= n ; i++){
        int t = - 1;  //找打未放入集合S的最小点
        for(int j = 1 ; j <= n; j++){
            if(!s[j] && (t == -1 || dist[t] > dist[j]))  t = j ;
        }
        s[t] = true;
        
        for(int j = 1 ; j <= n ; ++j){
            dist[j] = min(dist[j],dist[t] + g[t][j]);
        }
    }

   if(dist[n] == 0x3f3f3f3f)  return -1 ;
   else                       return dist[n];

}
int main(int argc, char const *argv[])
{
    cin >> n >> m; 
    memset(g,0x3f,sizeof g);
    while(m--){
        int x ,y ,w ;
        cin >> x >> y >> w ;
        g[x][y] = min(g[x][y],w);
    }
   cout<< dijstra() <<endl;
    return 0;
}
```

### 参考代码--堆优化版

```java
#include <iostream>
#include <cstring>
#include <queue>
using namespace std;
typedef pair<int,int> PII;
const int N = 1e5 + 10;
int n , m ;
int h[N],en[N],ne[N],w[N],idx = 0 ;
int dist[N];
bool used[N];
void insert(int x ,int y ,int ww){
    en[idx] = y , ne[idx] = h[x] , w[idx] = ww , h[x] = idx++;
}
void init(){
    memset(h,-1,sizeof h );
}

int dijstra(){
    memset(dist,0x3f,sizeof dist);
    dist[1] = 0 ;

    priority_queue<PII,vector<PII>, greater<PII>> heap;
    heap.push({0,1});    // 距离是0，点的编号是1

    while(heap.size()){
        auto t = heap.top();
        heap.pop();

        int ver = t.second , distance = t.first;
        if(used[ver]) continue;

        for(int i = h[ver]; i != -1 ; i = ne[i]){
            int j = en[i]; 
            if(dist[j] > distance + w[i] ){
                  dist[j] = distance + w[i];
                  heap.push({dist[j],j});  
               }
        }
    }
    if(dist[n] == 0x3f3f3f3f)  return -1 ;
    return dist[n];
}

int main(int argc, char const *argv[])
{
    int n , m;
    cin >> n >> m;
    init();
    while(m--){
        int x , y , w ;
        cin >> x >> y >> w ;
        insert(x,y,w);
    }
    cout << dist[n] << endl;
    return 0;
}
```

>>>>>>> 725fcb7a857252b3986fe8e21eadbeb0e3e3ddc6
