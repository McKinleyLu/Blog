---
title: 并查集
categories:
  - 基础算法
  - 竞赛
  - 竞赛模板
tags:
  - 并查集
  - c++
abbrlink: 61809
date: 2021-10-22 21:35:21
---


### 并查集

#### 用途
快速处理如下问题<!-- more -->
1. 将两个集合合并
2. 询问两个元素是否在一个集合中
在近乎O(1)时间内完成这两个操作

#### 基本原理
1. 每一个集合使用树来维护，根节点编号，代表一个树的编号
2. 每个节点保存它的父节点 p[x]表示x的父节点
3. 对于一个元素，不断找它的父节点，直到找到树根

#### 问题解决
1. 如何判断是否是树根:  if(p[x] == x)  // 令p[`树根标号`] = `树根标号`
2. 如何求x的集合编号:   while(p[x] != x) x = p[x];
3. 如何合并两个树:      让一个树根节点成为另一个树根节点的子节点  p[x] = y

#### 优化
一旦向上走找到根节点，则把树的所有节点挂在根节点下面(第一次需要判断n遍才知道属于哪个集合，下一次只需要一次就知道自己属于哪个集合)，全都成为根节点的节点，即`路径压缩`。

### 模板题目
一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。
现在要进行 m 个操作，操作共有两种：
`M a b`，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；
`Q a b`，询问编号为 a 和 b 的两个数是否在同一个集合中；

#### 输入格式

第一行输入整数 n 和 m。
接下来 m 行，每行包含一个操作指令，指令为 M a b 或 Q a b 中的一种。
#### 输出格式

对于每个询问指令 Q a b，都要输出一个结果，如果 a 和 b 在同一集合内，则输出 Yes，否则输出 No。
每个结果占一行。
数据范围
1≤n,m≤105

#### 输入样例：
```java
4 5
M 1 2
M 3 4
Q 1 2
Q 1 3
Q 3 4
```
#### 输出样例：
```java
Yes
No
Yes
```

### 代码模板
```java
#include<iostream>
using namespace std;

const int N = 1e5+10;
int n , m ;
int p[N];  

int find(int v){// 返回该节点的根节点 + 路径压缩
      if(p[x] != x)  p[x] = find(p[x]);
      return p[x];
}     
int main(){
   cin >> n >> m;
   for(int i = 1 ;  i<= n ; i++) p[i] = i ;
   while(m--){
       char op[2]; 
       int a , b ;
       cin >> op >> a >> b ;

       if(op=='M')  p[find(a)] = find(b)
       else{      // 判断两个元素是否在一个集合内
           if (find[a] == find[b])cout<<"Yes"<<end;
           else                   cout<<"No"<<endl;
       }
   }
    return 0 ;
}
```
[并查集的使用例题1](https://www.mckinleylu.com/2021/10/22/lian-tong-kuai-zhong-dian-de-shu-liang/)

[并查集的使用例题2](https://www.acwing.com/problem/content/242/)
