---
title: 最短Hamilton路径
date: 2021-10-03 22:37:32
cover: /img/6.jpg
categories: 
  - 算法
  - 算法进阶指南
tags: 
  - 位运算
  - 图论
  - C++
  - 算法-中等级
---

### 题目描述

给定一张 n 个点的带权无向图，点从 0∼n−1 标号，求起点 0 到终点 n−1 的最短 Hamilton 路径。<!-- more -->

Hamilton 路径的定义是从 0 到 n−1 不重不漏地经过每个点恰好一次。

#### 输入格式

第一行输入整数 n。

接下来 n 行每行 n 个整数，其中第 i 行第 j 个整数表示点 i 到 j 的距离（记为 a[i,j]）。

对于任意的 x,y,z数据保证 a[x,x]=0，a[x,y]=0  , a[x,y]=a[y,x] 并且 a[x,y]+a[y,z]≥a[x,z]。

#### 输出格式

输出一个整数，表示最短 Hamilton 路径的长度。

#### 数据范围

1≤ n ≤20
0≤ a[i,j] ≤10^7

#### 输入样例：

```
5
0 2 4 5 1       //0行
2 0 6 5 3
4 6 0 8 3
5 5 8 0 5
1 3 3 5 0
```

#### 输出样例：

```
18
```

### 题解

1. 首先根据题目，我们要经过图中所有点，且仅仅一次

2. 点的不同访问顺序会导致出现不同的代价，如

   * 0 - > 1 -> 2 -> 3     代价为 2 + 6 + 8 = 16
   * 0 - > 2 -> 1 -> 3      代价为4 + 6 + 5 = 15

3. 因此我们要聚焦两个问题 -- 构成二维数组：

   * 哪个点被用过                 一共20^2种情况
   * 目前停在哪个点             一共20中情况

4. 采用迪杰斯特拉方法，计算最短路径

   f[state] [j] ==  min(f[state_k] [ j] + weight[k] [j]   ,   f[state] [j])    其中state代表不含k点的集合，state_k代表含有k点的集合，f[state] [j] 表示当前在j点

5. state 10011 指的是当前state集合中，存在第1，2，5三个点，这里使用了状态压缩

### 参考代码

```c++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int N = 20, M = 1 << N;
int n ;
int f[M][N],weight[N][N];
int main(){
    cin >> n;
    for(int i = 0 ; i < n ; ++i){
        for(int j = 0 ; j < n ; ++j){
            cin >> weight[i][j];
        }
    }
    memset(f,0x3f,sizeof f);
    f[1][0] = 0 ;                          //初始化

    for(int i = 0 ; i < 1 << n ; ++i){     //  总共 1 << n 个  状态
        for(int j = 0 ; j < n ; ++j){      
            if(i >> j  & 1){               //  判断当前状态是否含有j这个点  
                for(int k = 0 ; k < n ; ++k){
                    if(i - (1 << j ) >> k & 1){  // 移位优先级小于加减法优先级   判断k点是否在state集合中
                       f[i][j] = min(f[i][j],f[i - (1 << j)][k] + weight[k][j]);
                    }
                }
            }
        }
    }
    cout<<f[(1 << n) - 1][n-1];                 //二维数组最后一个元素，即为最短路径代价
    return 0;
}
```

### 代码解释与本题思想

1. 为何把数组定义到函数外？

   因为函数在栈中，栈只有4M，而全局静态变量在堆中，堆的空间大

2. memset(f,0x3f,sizeof f)什么含义

   表示将数组所有值设置成无穷大

3. 状态压缩法，利用位运算，实现集合元素的压缩表示

4. 迪杰斯特拉原理的理解，由于本题图为完全图，因此所有点都之间都存在一条直接相连的边