---
title: 哈希
categories:
  - 基础算法
  - 竞赛
  - 竞赛模板
tags:
  - 哈希表
  - c++
abbrlink: 56027
date: 2021-10-23 23:19:12
---

### 哈希Hash

1. 哈希表写法
2. 字符串哈希方式

#### 存储结构(解决冲突)<!-- more -->
1. 拉链法
   把一个大数据，映射到一个比较小的范围。 例如 ： 0 - 10^9.  -> 0 - 10^5
2. 例题： 模拟散列表
   使用哈希函数，利用 x mod 10^5  就把数字映射到0 - 10^5 - 1 之间

```java
  #include<iostream> 
   using namespace std ;
   const int N = 1e5 + 10;
   int h[N] , e[N] , ne[N] ,  idx;
   /**
    * 其中 ， h[N]是槽，用来保存每一个链表的头地址
    *        e[N]是每个槽对应的一个链表，采用头插法，链表第一个元素是有值的
    *        ne[N]对应链表中每一个元素的next元素的下标
   */
   void insert(int x){
       // 想一个哈希函数。k为哈希值
        int k = (x % N + N) % N;  //把x映射到从0到N x % N + N目的是取模让其变成整数
       e[idx] = x , ne[idx] = h[k] , h[k] = idx++;     
 
   }

   bool find(int x){
       int k = (x % N + N) % N;
       for(int i = h[k] ; i != -1 ;i = ne[i]){
           if(e[i] == x)  return true;
       }
       return false;
   }
   int main(){
       int n ; 
       cin >> n ;
        memset(h,-1,sizeof h) ;  //清空所有槽
       while(n--){
        char op[2];
        int x ;
        cin >>op >> x;

        if(op[0] == 'I') insert(x);
        else             {
            if(find(x)) cout<<"Yes"<<endl;
            else        cout<<"No"<<endl;
        }
       }

       return 0 ;
   }

```

2. 开放寻址法
   只开一个数组，其大小为原来数字的2倍
   h(x) = k
   查找：首先定位其位置，若有元素，如果元素值不是，就进行循序查找
   删除：先查找，找到后打一个标记即可

   ```java
   const int ns = 1e10 ,null = 0x3f3f3f3f;
   int h[ns];
   int N = 0;
   // 首先找一个大于2e10的质数
   long long findnum(int n){
      for(int i = n; i++){
          bool flag = true;
          for(int j = 2 ; j <= i ; ++j){
              if(i % j == 0) flag = false , break;
          }
          if(flag) cout<i<<endl, return i ;
      }
   }
   int find(int x){ // 如果x在哈希表中，则返回其位置；如果不在，就返回他应该在的位置
       int k = (x % N + N) % N;
       while(h[k] != null && h[k] != k){
           k++;
           if(k == N) k = 0 ;
       }
       return k ;
   }
   int main(){
       int n ; 
       cin >> n ;
   
       memset(h,0x3f,sizeof h); // meset是按照字节复制，是指是赋值 0x3f3f3f3f
   
       N = findnum(ns);
       while(n--){
           int x;
           char op[2];
           cin>>op>>x;
           int m = find(x)
           if(op[0] == 'I') h[k] = x;
           else{
               if(h[k] != null) cout<<"Yes"<<endl;
               else             cout<<"No"<<endl;
           }
       }
       return 0 ;
   }
   ```


#### 字符串前缀哈希法
str = "abcdefghi"
h[0] = 0 
h[1] = 前一个数的哈希值("a"的哈希值)    
h[2] = 前两个数的哈希值("ab"的哈希值)
...      ...
采用p进制
如 h[4] =  "A B C D" 的哈希值  = (1 2 3 4)<sub>p<sub> = 1 * p^3 + 2 * p^2 + ... + 4 * p ^0  mod Q；

* 不要把某一字母映射0
* 经验值: 当p取131、13331，Q取2^64,一般不会出现冲突
可以利用前缀哈希，计算出所有字符串哈希值,即把所有前m的子串映射成数字
如何计算`[l ,r]`这个区间的子串哈希值  `h = h[r] - h[l]* p ^(r-l+1)`

技巧：使用unsign long long (2^64) 则它的数字的溢出就是mod2^64

**本结论用于花费`O(1)`的时间判断一个字符串中两个区间内的子串是否相同**
#### 代码模板
```java
#include<iostream>
using namespace std;
typedef unsign long long  ULL;
const int N = 100010, P = 131;
int n , m ;
char str[N];
ULL h[N],p[N];
ULL get(int l ,int r){
    return h[r] - h[l] * p[r - l + 1];
}
int main(){
    cin >> n >> m ;
    cin > str+1;
    p[0] = 1 ;
    for(int i = 1; i <= n ; i++){
        p[i] = p[i - 1] * P;
        h[i] = h[i - 1] * P + str[i];
    }

    while(m--){
        int l1 , l2 , r1 , r2 ;
        cin >> l1 >> l2 >> r1 >> r2;
        if(get(l1,r1) == get(l2,r2)) cout<<"Yes"<<endl;
        else                         cout<<"No"<<end;
    }
    return 0 ;
}
```

