<<<<<<< HEAD
---
title: 前缀与差分
categories:
  - 基础算法
tags:
  - 前缀
  - 差分
  - week1
abbrlink: 36339
date: 2021-10-21 10:13:53
---

## 前缀与差分

### 前缀

其实质是数组的前i项和。<!-- more -->

### 一维前缀

原数组 ： a1 a2 a3 a4 ... an

前缀和 :    Si = a1 + a2 + ...+ ai

#### 计算与应用

计算：   令 `s0 =  0 `;     `s[i] =  s[i-1] + a[i]`

应用(也是唯一应用)：  可以直接求出[l , r]下标区间内元素和 `value = s[r] - s[l-1]`

#### 代码模板

```java
const int N = 1e5 + 10 ;
int a[N],s[N];

int main(){
    ios::sync_with_stdio(false);    // 使得cin 与 scanf 速度相同 ，但是以后不得再使用scanf，只能用cin
    int n ;
    cin >> n ;
    for(int i = 1  ; i <= n ; ++i)  cin >> a[i];
    
    s[0] = 0 ;  // 重点理解
    for(int s = 1  ; s <= n ; ++i)  s[i] = s[i-1] + a[i];

    int l , r ;
    cin >> l >> r ;
    int ans = s[r] - s[l-1];    // 重点理解

     return 0 ;
}
```

### 二维前缀

Si,j 表示左上角所有元素之和

#### 计算

前缀和 => ` s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];`

子矩阵面积 => ` S(x2,y2) - S(x1 - 1,y2) - S(x2,y1 - 1) + S(x1,y1) `

![picture](/img/jcsf4.jpg)

#### 代码模板

```java
void work(){
    // 构造二维前缀和(黄色部分)
    for(int i = 1 ; i <= n ; ++i)
        for(int j = 1 ; j <= n ; ++j)
            s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];
    
    // 询问子矩阵(蓝色部分)
    while(cnt--){
        int x1 ,y1 ,x2 ,y2;
        cin >> x1 >> y1 >> x2 >> y2;
        int ans = s[x2][y2] - s[x1][y2] - s[x2][y1] + s[x1][y1]
        cout<<ans<<endl;
    }
    
}
```

### 差分

前缀和逆运算

对于数列  a1, a2 ,a3 ,... ,an

构造  b1,b2,b3,...,bn

使得  ai =  b1 + b2 + .... + bi

#### 一维差分构造方法

b1 = a1 

b2 = a2 - a1

bn = an - a(n-1)

#### 一维差分应用

使序列a的[l,r]`区间内数字都加一个值c,`如果遍历相加，则需要O(n)

若使`b[l] += c  b[r+1] -= c` 来实现，则需要O(1)的时间

#### 一维差分代码模板

```java
// 使得区间[l,r]内元素全部加一
void insert(int l ,int r ,int c){
     b[l]   += c;
     b[r+1] -= c;
}

//构造
b[1] = a[1] ;
for(int i = 2 ; i <= n ; ++1) b[i] = a[i] - a[i-1];
cin >> l >> r >> c;
insert(l,r,c);
```

#### 二维差分数组

只要满足原矩阵是差分数组之和即可

#### 二维差分数组计算方法

对于二维差分，即对一个子矩阵加一个c值即可

若想给(x1,y1) 到 (x2,y2)内的子矩阵加c，使用b[x1,y1] + c ，相当于右下角全部加c,  因此需要进行如下处理

`b[x1,y1] += c`     ` b[x1][y1 + 1]-= c `   `b[x1 + 1][y1] -= c`  `b[x1 + 1][y1 + 1] += c`     

![picture](/img/jcsf5.jpg)

#### 代码模板

#### 二维差分代码模板

```java
//2022.2.27 复习
void  insert(int x1 , int y1 , int x2 ,int y2 , int c){
       b[x1][y1] += c ;
       b[x1 + 1][y1] -= c ;
       b[x1][y1 + 1] -= c;
       b[x1+1][y1+1] += c;
}

int main(){
    
    for(int i =1 ; i <= n ; ++i)
        for(int j = =1; j <= n ; ++j)
            cin >> a[i][j];
    
    //构造差分矩阵
    for(int i =1 ; i <= n ; ++i)
        for(int j = 1; j <= n ; ++j)
            insert(i,j,i,j,a[i][j]);
    
    // 对部分子矩阵值进行加减
    while(q--){
        int x1 , y1 , x2 ,y2 , c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        insert(x1,y1,x2,y2,c);
    }
    
    // 计算b的前缀和，即对部分子矩阵值进行加减 a数组的值，并保存在b矩阵中
    for(int i = 1 ; i <= n; i++)
        for(int j = 1; j <= n ; ++j)
            b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1];
    
    // 打印a数组的值
    for(int i = 1 ; i <= n; i++)
        for(int j = 1; j <= n ; ++j)
             cout<<b[i][j]<<" ";
    	cout<<endl;
    return 0 ;
}
```

### 前缀与差分例题

#### 一维前缀和

注意以下两点：

* 求[l,r]区间和:`ans = s[r] - s[l - 1]`
* s[0] = 0 
* s[i] = s[i -1 ] + a[i]

##### 题目描述

输入一个长度为n的整数序列。

接下来再输入m个询问，每个询问输入一对l, r。

对于每个询问，输出原序列中从第l个数到第r个数的和。

##### 输入格式

第一行包含两个整数n和m。

第二行包含n个整数，表示整数数列。

接下来m行，每行包含两个整数l和r，表示一个询问的区间范围。

##### 输出格式

共m行，每行输出一个询问的结果。

##### 数据范围

1≤l≤r≤n,
1≤n,m≤100000,
−1000≤数列中元素的值≤1000

##### 输入样例：

```java
5 3
2 1 3 6 4
1 2
1 3
2 4
```

##### 输出样例:

```java
3
6
10
```

##### 参考代码

```java
//2022.2.27 复习
#include<iostream>
using namespace std ;
const int N  = 1e5 + 10 ;
int a[N],S[N];
int n , m;
int main(int argc, char const *argv[])
{
    cin >> n >> m ;
    S[0] = 0 ;
    for(int i = 1 ; i <= n ; ++i){
        cin >> a[i];
        S[i]  =  S[i - 1] + a[i];
    }
    while(m--){
        int l , r ;
        cin >> l >> r ;
        cout << S[r] - S[l-1] << endl;
    }
    return 0;
}
```

#### 二维前缀和以及子矩阵值计算

注意一下几点:

* 二维前缀和公式: `s[ i ] [ j ] = s[ i - 1] [ j ]  + s[ i ] [ j - 1] - s[ i - 1 ] [j  - 1] + a[ i ] [ j ]`
* 子矩阵计算公式:`s[x2][y2] - s[x2][y1 - 1] - s[x1 -1][y2] + s[x1 - 1 ][y1 - 1]`

##### 题目描述

输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。

对于每个询问输出子矩阵中所有数的和。

##### 输入格式

第一行包含三个整数n，m，q。

接下来n行，每行包含m个整数，表示整数矩阵。

接下来q行，每行包含四个整数x1, y1, x2, y2，表示一组询问。

##### 输出格式

共q行，每行输出一个询问的结果。

##### 数据范围

1 ≤n,m≤ 1000,
1 ≤q≤ 200000,
1 ≤x1≤x2 ≤n,
1 ≤y1≤y2 ≤m,
−1000 ≤矩阵内元素的值 ≤1000

##### 输入样例：

```java
3 4 3
1 7 2 4
3 6 2 8
2 1 2 3
1 1 2 2
2 1 3 4
1 3 3 4
```

##### 输出样例:

```java
17
27
21
```

##### 参考代码

```java
//2022.2.27 复习
#include<iostream>
using namespace std ;
const int N  = 1e3 + 10 ;
int a[N][N] , s[N][N];
int n , m , q;
int main(int argc, char const *argv[])
{
    cin >> n >> m >> q;
    s[0][0] = 0 ;
    for(int i = 1 ; i <= n ; ++i){
       for(int j = 1 ; j <= m ; ++j){
           cin >> a[i][j];
           s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];
       }
    }
    while(q--){
        int x1,y1,x2,y2;
        cin >> x1 >> y1 >> x2 >> y2 ;
        int ans = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1-1] + s[x1 - 1][y1 - 1];
        cout << ans <<endl;
    }
    return 0;
}

```

#### 一维差分

注意以下几点：

* b[ 0 ] = a[ 0 ]
* 应用： 将区间[l,r]中数加c:`b[l] += c , b[r+1] -= c`

##### 题目描述

输入一个长度为n的整数序列。
接下来输入m个操作，每个操作包含三个整数l，r，c，表示将序列中[l，r]之间的每个数加上c。
请你输出进行完所有操作后的序列。

##### 输入格式

第一行包含两个整数n和m。
第二行包含n个整数，表示整数序列。
接下来m行，每行包含三个整数l，r，c，表示一个操作。

##### 输出格式

共一行，包含n个整数，表示最终序列。
数据范围
1   ≤ n，m≤ 100000，
1   ≤ l ≤ r ≤  n，-1000≤c≤1000，
-1000 ≤整数序列中元素的值≤ 1000

##### 输入样例：

```java
6 3
1 2 2 1 2 1
1 3 1
3 5 1
1 6 1
```

##### 输出样例:

```java
3 4 5 3 4 2
```

##### 参考代码

```java
//2022.2.27 复习
#include<iostream>
using namespace std ;
const int N = 1e5 +10;
int a[N] , b[N];
int n , m ;
int main(int argc, char const *argv[])
{
    cin >> n >> m ;
    for(int i = 1  ;i <= n ; ++i)  cin >> a[i];
    b[1] = a[1] ;
    for(int i = 2 ; i <= n ; ++i ) b[i] = a[i] - a[i - 1];
    while(m--){
        int l , r ,c ;
        cin >> l >> r >> c ;
        b[l] += c , b[r +1] -= c ;
    }
    int res = 0 ;
    for(int i = 1 ; i <= n ; ++i){
        res += b[i];
        cout << res <<" ";
    }
    return 0;
}
```

#### 差分矩阵

注意以下几点：

* 对`x1,y1,x2,y2`围成的区域加c，使用公式`b[x1][y1] += c , b[x1][y2 + 1] -= c , b[x2 + 1][y1] -= c , b[x2 + 1] [y2 + 1] += c`
* 求二维差分公式: 公式和上述公式一样
* 二维差分数组`b`采用二维前缀和方式，即可计算出元素数值

##### 题目描述

输入一个n行m列的整数矩阵，再输入q个操作，每个操作包含五个整数x1, y1, x2, y2, c，其中(x1, y1)和(x2, y2)表示一个子矩阵的左上角坐标和右下角坐标。
每个操作都要将选中的子矩阵中的每个元素的值加上c。
请你将进行完所有操作后的矩阵输出。

##### 输入格式

第一行包含整数n,m,q。
接下来n行，每行包含m个整数，表示整数矩阵。
接下来q行，每行包含5个整数x1, y1, x2, y2, c，表示一个操作。

##### 输出格式
 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。
##### 数据范围
1≤n,m≤1000
1≤q≤100000
1≤x1≤x2≤n
1≤y1≤y2≤m
−1000≤c≤1000
−1000≤矩阵内元素的值≤1000

##### 输入样例

```java
3 4 3
1 2 2 1
3 2 2 1
1 1 1 1
1 1 2 2 1
1 3 2 3 2
3 1 3 4 1
```

##### 输出样例

```java
2 3 4 1
4 3 4 1
2 2 2 2
```

##### 参考代码

```java
//2022.2.27 复习
#include <iostream>
using namespace std;
const int N  = 1e3 + 10;
int a[N][N] , b[N][N];
int n , m , q;
void insert(int x1 ,int y1 , int x2 , int y2 , int c){
    b[x1][y1]   += c ;
    b[x1][y2+1] -=c ;
    b[x2+1][y1] -= c;
    b[x2+1][y2+1]   += c ;
}
int main(int argc, char const *argv[])
{
    cin >> n >> m >> q;
    //输入原数组，同时计算二维方差矩阵
    for(int i = 1 ; i <= n ; ++i){
        for(int j = 1 ; j <= m ; ++j){
            cin >> a[i][j];
            insert(i,j,i,j,a[i][j]);
        }
    }
    //对二维方差矩阵进行相应数值计算
    while(q--){
        int x1,y1,x2,y2,c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        insert(x1,y1,x2,y2,c);
    }
    //对二维方差矩阵进行二维数组求和，和即为更改过后的原数组
    for(int i = 1 ; i <= n ; ++i){
        for(int j = 1 ; j <= m ;++j){
            b[i][j] +=  b[i-1][j] + b[i][j-1] - b[i-1][j-1];
        }
    }
    //输出原数组
    for(int i = 1 ; i <= n ; ++i){
        for(int j = 1 ; j <= m ; ++j){
            cout << b[i][j] <<" ";
        }
        cout << endl;
    }
    return 0;
}
```

=======
---
title: 前缀与差分
categories:
  - 基础算法
tags:
  - 前缀
  - 差分
  - week1
abbrlink: 36339
date: 2021-10-21 10:13:53
---

## 前缀与差分

### 前缀

其实质是数组的前i项和。<!-- more -->

### 一维前缀

原数组 ： a1 a2 a3 a4 ... an

前缀和 :    Si = a1 + a2 + ...+ ai

#### 计算与应用

计算：   令 `s0 =  0 `;     `s[i] =  s[i-1] + a[i]`

应用(也是唯一应用)：  可以直接求出[l , r]下标区间内元素和 `value = s[r] - s[l-1]`

#### 代码模板

```java
const int N = 1e5 + 10 ;
int a[N],s[N];

int main(){
    ios::sync_with_stdio(false);    // 使得cin 与 scanf 速度相同 ，但是以后不得再使用scanf，只能用cin
    int n ;
    cin >> n ;
    for(int i = 1  ; i <= n ; ++i)  cin >> a[i];
    
    s[0] = 0 ;  // 重点理解
    for(int s = 1  ; s <= n ; ++i)  s[i] = s[i-1] + a[i];

    int l , r ;
    cin >> l >> r ;
    int ans = s[r] - s[l-1];    // 重点理解

     return 0 ;
}
```

### 二维前缀

Si,j 表示左上角所有元素之和

#### 计算

前缀和 => ` s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];`

子矩阵面积 => ` S(x2,y2) - S(x1 - 1,y2) - S(x2,y1 - 1) + S(x1,y1) `

![picture](/img/jcsf4.jpg)

#### 代码模板

```java
void work(){
    // 构造二维前缀和(黄色部分)
    for(int i = 1 ; i <= n ; ++i)
        for(int j = 1 ; j <= n ; ++j)
            s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];
    
    // 询问子矩阵(蓝色部分)
    while(cnt--){
        int x1 ,y1 ,x2 ,y2;
        cin >> x1 >> y1 >> x2 >> y2;
        int ans = s[x2][y2] - s[x1][y2] - s[x2][y1] + s[x1][y1]
        cout<<ans<<endl;
    }
    
}
```

### 差分

前缀和逆运算

对于数列  a1, a2 ,a3 ,... ,an

构造  b1,b2,b3,...,bn

使得  ai =  b1 + b2 + .... + bi

#### 一维差分构造方法

b1 = a1 

b2 = a2 - a1

bn = an - a(n-1)

#### 一维差分应用

使序列a的[l,r]`区间内数字都加一个值c,`如果遍历相加，则需要O(n)

若使`b[l] += c  b[r+1] -= c` 来实现，则需要O(1)的时间

#### 一维差分代码模板

```java
// 使得区间[l,r]内元素全部加一
void insert(int l ,int r ,int c){
     b[l]   += c;
     b[r+1] -= c;
}

//构造
b[1] = a[1] ;
for(int i = 2 ; i <= n ; ++1) b[i] = a[i] - a[i-1];
cin >> l >> r >> c;
insert(l,r,c);
```

#### 二维差分数组

只要满足原矩阵是差分数组之和即可

#### 二维差分数组计算方法

对于二维差分，即对一个子矩阵加一个c值即可

若想给(x1,y1) 到 (x2,y2)内的子矩阵加c，使用b[x1,y1] + c ，相当于右下角全部加c,  因此需要进行如下处理

`b[x1,y1] += c`     ` b[x1][y1 + 1]-= c `   `b[x1 + 1][y1] -= c`  `b[x1 + 1][y1 + 1] += c`     

![picture](/img/jcsf5.jpg)

#### 代码模板

#### 二维差分代码模板

```java
//2022.2.27 复习
void  insert(int x1 , int y1 , int x2 ,int y2 , int c){
       b[x1][y1] += c ;
       b[x1 + 1][y1] -= c ;
       b[x1][y1 + 1] -= c;
       b[x1+1][y1+1] += c;
}

int main(){
    
    for(int i =1 ; i <= n ; ++i)
        for(int j = =1; j <= n ; ++j)
            cin >> a[i][j];
    
    //构造差分矩阵
    for(int i =1 ; i <= n ; ++i)
        for(int j = 1; j <= n ; ++j)
            insert(i,j,i,j,a[i][j]);
    
    // 对部分子矩阵值进行加减
    while(q--){
        int x1 , y1 , x2 ,y2 , c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        insert(x1,y1,x2,y2,c);
    }
    
    // 计算b的前缀和，即对部分子矩阵值进行加减 a数组的值，并保存在b矩阵中
    for(int i = 1 ; i <= n; i++)
        for(int j = 1; j <= n ; ++j)
            b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1];
    
    // 打印a数组的值
    for(int i = 1 ; i <= n; i++)
        for(int j = 1; j <= n ; ++j)
             cout<<b[i][j]<<" ";
    	cout<<endl;
    return 0 ;
}
```

### 前缀与差分例题

#### 一维前缀和

注意以下两点：

* 求[l,r]区间和:`ans = s[r] - s[l - 1]`
* s[0] = 0 
* s[i] = s[i -1 ] + a[i]

##### 题目描述

输入一个长度为n的整数序列。

接下来再输入m个询问，每个询问输入一对l, r。

对于每个询问，输出原序列中从第l个数到第r个数的和。

##### 输入格式

第一行包含两个整数n和m。

第二行包含n个整数，表示整数数列。

接下来m行，每行包含两个整数l和r，表示一个询问的区间范围。

##### 输出格式

共m行，每行输出一个询问的结果。

##### 数据范围

1≤l≤r≤n,
1≤n,m≤100000,
−1000≤数列中元素的值≤1000

##### 输入样例：

```java
5 3
2 1 3 6 4
1 2
1 3
2 4
```

##### 输出样例:

```java
3
6
10
```

##### 参考代码

```java
//2022.2.27 复习
#include<iostream>
using namespace std ;
const int N  = 1e5 + 10 ;
int a[N],S[N];
int n , m;
int main(int argc, char const *argv[])
{
    cin >> n >> m ;
    S[0] = 0 ;
    for(int i = 1 ; i <= n ; ++i){
        cin >> a[i];
        S[i]  =  S[i - 1] + a[i];
    }
    while(m--){
        int l , r ;
        cin >> l >> r ;
        cout << S[r] - S[l-1] << endl;
    }
    return 0;
}
```

#### 二维前缀和以及子矩阵值计算

注意一下几点:

* 二维前缀和公式: `s[ i ] [ j ] = s[ i - 1] [ j ]  + s[ i ] [ j - 1] - s[ i - 1 ] [j  - 1] + a[ i ] [ j ]`
* 子矩阵计算公式:`s[x2][y2] - s[x2][y1 - 1] - s[x1 -1][y2] + s[x1 - 1 ][y1 - 1]`

##### 题目描述

输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。

对于每个询问输出子矩阵中所有数的和。

##### 输入格式

第一行包含三个整数n，m，q。

接下来n行，每行包含m个整数，表示整数矩阵。

接下来q行，每行包含四个整数x1, y1, x2, y2，表示一组询问。

##### 输出格式

共q行，每行输出一个询问的结果。

##### 数据范围

1 ≤n,m≤ 1000,
1 ≤q≤ 200000,
1 ≤x1≤x2 ≤n,
1 ≤y1≤y2 ≤m,
−1000 ≤矩阵内元素的值 ≤1000

##### 输入样例：

```java
3 4 3
1 7 2 4
3 6 2 8
2 1 2 3
1 1 2 2
2 1 3 4
1 3 3 4
```

##### 输出样例:

```java
17
27
21
```

##### 参考代码

```java
//2022.2.27 复习
#include<iostream>
using namespace std ;
const int N  = 1e3 + 10 ;
int a[N][N] , s[N][N];
int n , m , q;
int main(int argc, char const *argv[])
{
    cin >> n >> m >> q;
    s[0][0] = 0 ;
    for(int i = 1 ; i <= n ; ++i){
       for(int j = 1 ; j <= m ; ++j){
           cin >> a[i][j];
           s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];
       }
    }
    while(q--){
        int x1,y1,x2,y2;
        cin >> x1 >> y1 >> x2 >> y2 ;
        int ans = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1-1] + s[x1 - 1][y1 - 1];
        cout << ans <<endl;
    }
    return 0;
}

```

#### 一维差分

注意以下几点：

* b[ 0 ] = a[ 0 ]
* 应用： 将区间[l,r]中数加c:`b[l] += c , b[r+1] -= c`

##### 题目描述

输入一个长度为n的整数序列。
接下来输入m个操作，每个操作包含三个整数l，r，c，表示将序列中[l，r]之间的每个数加上c。
请你输出进行完所有操作后的序列。

##### 输入格式

第一行包含两个整数n和m。
第二行包含n个整数，表示整数序列。
接下来m行，每行包含三个整数l，r，c，表示一个操作。

##### 输出格式

共一行，包含n个整数，表示最终序列。
数据范围
1   ≤ n，m≤ 100000，
1   ≤ l ≤ r ≤  n，-1000≤c≤1000，
-1000 ≤整数序列中元素的值≤ 1000

##### 输入样例：

```java
6 3
1 2 2 1 2 1
1 3 1
3 5 1
1 6 1
```

##### 输出样例:

```java
3 4 5 3 4 2
```

##### 参考代码

```java
//2022.2.27 复习
#include<iostream>
using namespace std ;
const int N = 1e5 +10;
int a[N] , b[N];
int n , m ;
int main(int argc, char const *argv[])
{
    cin >> n >> m ;
    for(int i = 1  ;i <= n ; ++i)  cin >> a[i];
    b[1] = a[1] ;
    for(int i = 2 ; i <= n ; ++i ) b[i] = a[i] - a[i - 1];
    while(m--){
        int l , r ,c ;
        cin >> l >> r >> c ;
        b[l] += c , b[r +1] -= c ;
    }
    int res = 0 ;
    for(int i = 1 ; i <= n ; ++i){
        res += b[i];
        cout << res <<" ";
    }
    return 0;
}
```

#### 差分矩阵

注意以下几点：

* 对`x1,y1,x2,y2`围成的区域加c，使用公式`b[x1][y1] += c , b[x1][y2 + 1] -= c , b[x2 + 1][y1] -= c , b[x2 + 1] [y2 + 1] += c`
* 求二维差分公式: 公式和上述公式一样
* 二维差分数组`b`采用二维前缀和方式，即可计算出元素数值

##### 题目描述

输入一个n行m列的整数矩阵，再输入q个操作，每个操作包含五个整数x1, y1, x2, y2, c，其中(x1, y1)和(x2, y2)表示一个子矩阵的左上角坐标和右下角坐标。
每个操作都要将选中的子矩阵中的每个元素的值加上c。
请你将进行完所有操作后的矩阵输出。

##### 输入格式

第一行包含整数n,m,q。
接下来n行，每行包含m个整数，表示整数矩阵。
接下来q行，每行包含5个整数x1, y1, x2, y2, c，表示一个操作。

##### 输出格式
 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。
##### 数据范围
1≤n,m≤1000
1≤q≤100000
1≤x1≤x2≤n
1≤y1≤y2≤m
−1000≤c≤1000
−1000≤矩阵内元素的值≤1000

##### 输入样例

```java
3 4 3
1 2 2 1
3 2 2 1
1 1 1 1
1 1 2 2 1
1 3 2 3 2
3 1 3 4 1
```

##### 输出样例

```java
2 3 4 1
4 3 4 1
2 2 2 2
```

##### 参考代码

```java
//2022.2.27 复习
#include <iostream>
using namespace std;
const int N  = 1e3 + 10;
int a[N][N] , b[N][N];
int n , m , q;
void insert(int x1 ,int y1 , int x2 , int y2 , int c){
    b[x1][y1]   += c ;
    b[x1][y2+1] -=c ;
    b[x2+1][y1] -= c;
    b[x2+1][y2+1]   += c ;
}
int main(int argc, char const *argv[])
{
    cin >> n >> m >> q;
    //输入原数组，同时计算二维方差矩阵
    for(int i = 1 ; i <= n ; ++i){
        for(int j = 1 ; j <= m ; ++j){
            cin >> a[i][j];
            insert(i,j,i,j,a[i][j]);
        }
    }
    //对二维方差矩阵进行相应数值计算
    while(q--){
        int x1,y1,x2,y2,c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        insert(x1,y1,x2,y2,c);
    }
    //对二维方差矩阵进行二维数组求和，和即为更改过后的原数组
    for(int i = 1 ; i <= n ; ++i){
        for(int j = 1 ; j <= m ;++j){
            b[i][j] +=  b[i-1][j] + b[i][j-1] - b[i-1][j-1];
        }
    }
    //输出原数组
    for(int i = 1 ; i <= n ; ++i){
        for(int j = 1 ; j <= m ; ++j){
            cout << b[i][j] <<" ";
        }
        cout << endl;
    }
    return 0;
}
```

>>>>>>> 725fcb7a857252b3986fe8e21eadbeb0e3e3ddc6
