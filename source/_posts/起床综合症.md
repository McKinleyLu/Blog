---
title: 起床综合症
toc: true
cover: /img/2.jpg
categories:
  - 算法
  - 算法进阶指南
tags:
  - 位运算
  - C++
  - 算法-中等级
abbrlink: 30860
date: 2021-10-05 17:52:02
---
### 题目描述

具体说来，drd 的防御战线由 n 扇防御门组成。

每扇防御门包括一个运算 op 和一个参数 t，其中运算一定是 OR,XOR,AND 中的一种，参数则一定为非负整数。<!-- more -->

如果还未通过防御门时攻击力为 x，则其通过这扇防御门后攻击力将变为 x op t。

最终 drd 受到的伤害为对方初始攻击力 x 依次经过所有 n 扇防御门后转变得到的攻击力。

由于 atm 水平有限，他的初始攻击力只能为 0 到 m 之间的一个整数（即他的初始攻击力只能在 0,1,…,m 中任选，但在通过防御门之后的攻击力不受 m 的限制）。

为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使 drd 受到多少伤害。

#### 输入格式

第 1 行包含 2 个整数，依次为 n,m，表示 drd 有 n 扇防御门，atm 的初始攻击力为 0 到 m 之间的整数。

接下来 n 行，依次表示每一扇防御门。每行包括一个字符串 op 和一个非负整数 t，两者由一个空格隔开，且 op 在前，t 在后，op 表示该防御门所对应的操作，t 表示对应的参数。

#### 输出格式

输出一个整数，表示 atm 的一次攻击最多使 drd 受到多少伤害。

#### 数据范围

![公式1](/img/saunfa1.png)

#### 输入样例：

```
3 10
AND 5
OR 6
XOR 7
```

#### 输出样例：

```
1
```

#### 样例解释

atm可以选择的初始攻击力为 0,1,…,10。

假设初始攻击力为 4，最终攻击力经过了如下计算

4 AND 5 = 4

4 OR 6 = 6

6 XOR 7 = 1
类似的，我们可以计算出初始攻击力为 1,3,5,7,9 时最终攻击力为 0，初始攻击力为 0,2,4,6,8,10 时最终攻击力为 1，因此 atm 的一次攻击最多使 drd 受到的伤害值为 1。

### 题目分析

1. 本题简化描述为：输入一个数m，经过`AND`、`OR`、`XOR`多次逻辑运算，得到的结果最大

2. 参考思路

   * 对m的可能有的每一位进行枚举，**因为每一位都是独立互不影响**，因此彼此之间并不影响，我们只需要确定每一位经过一些系列逻辑运算后，值取到最大即可。

   * 本题中 m 最大是 10 ^ 9，log2(10 ^ 9) = 3log2(10 ^ 3) < 3 * 10 = 30，所以每次 i 从 29 往后枚举就可以了
   * 如果该位填 1 后，所得到的数大于 m，那么该位填 0；否则如果该位填 1 后，所得到的数对 n 个数都运算之后，结果小于等于该位填 0 后得到的结果，那么为了让剩下能填的数更大，该位填 0；否则该位填 1。

### 时间复杂度

一共要判断 logm次，每次判断是 O(n)的，所以总的时间复杂度是  O(nlogm)

### 参考代码

```c++
/**
 * @file 4.cpp
 * @author your name (you@domain.com)
 * @brief 
 * @version 0.1
 * @date 2021-10-05
 * @copyright Copyright (c) 2021
 */
#include<iostream>
#include<algorithm>
using namespace std;
// 因为本题中 m 最大是 10 ^ 9，log2(10 ^ 9) = 3log2(10 ^ 3) < 3 * 10 = 30，所以每次 i 从 29 往后枚举就可以了
// << 左移   >> 右移
// 优先级：    算数运算 > 移位运算 > 位运算  
// 异或 ^=
const int N = 100005;
int op[N];
int q[N];
int n , m ;
int ans = 0 ;
int cal(int value , int pos){
    for(int i = 0; i < n ; ++i){
        if(op[i] == 1)       {value &= q[i] >> pos & 1 ; }
        else if(op[i] == 2)  {value |= q[i] >> pos & 1 ; }
        else                 {value ^= q[i] >> pos & 1 ; }
    }
    return value;
}
int main(){
   cin >> n >> m ;
   for(int i = 0; i < n ; ++i){
       string str;
       cin >> str >> q[i];
       if(str == "AND")          {op[i] = 1;}
       else if(str == "OR")      {op[i] = 2;}
       else                      {op[i] = 3;}
   }
   for(int i = 29 ; ~ i ; --i){
       if(m >> i){
             int x = cal(0,i) , y = cal(1,i);
             if(x >= y )  {ans |= x << i;}
             else        ans |= y << i;
       }
       else{
           ans |= cal(0,i) << i ;
       }
   }
   cout << ans;
    return  0 ;
}
```

