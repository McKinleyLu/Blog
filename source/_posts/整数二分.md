<<<<<<< HEAD
<<<<<<< HEAD
---
title: 二分法
categories:
  - 基础算法
tags:
  - 二分法
  - week1
abbrlink: 64680
date: 2021-10-18 20:46:57
---

## 二分法

 整数二分： 有单调性一定可以二分  给定区间，定义某种性质，左区间不满足性质，右边区间。满足由于是整数二分，所以两个区间边界不重合<!-- more -->

移位运算的优先级小于算术运算，所以 l + r >> 1 无需加括号

### 二分本质： 寻找性质边界

一个问题有某个性质，左半边不满足，而右半边满足，则可以使用二分,寻找出性质边界。

### 整数二分

![picture](/img/erfen.jpg)

#### 二分出红色边界

* mid = (l  + r + 1) >> 1  （为何加1，看下面说明）
* if (check(mid))  为true，答案一定在[mid , r] 中 ， 更新方式  l = mid
* if (check(mid))  为false, 答案一定在[l,mid-1]中  ，更新方式 r = mid - 1

#### 二分出绿色边界

* mid = (l  + r) >> 1
* if (check(mid))  为true，答案一定在[l,mid] 中 ， 更新方式  r = mid
* if (check(mid))  为false, 答案一定在[mid+1,r]中，更新方式  l  = mid + 1

#### 解决实际问题步骤

首先写出check()函数，然后想找的红色还是绿色边界

#### 问题解答

 当 l =  r - 1 , mid = l + r >> 1 ,由于整数下取整，则 mid  = l 若为true , 则 l = mid ,其实就是l还是等于原来的l，陷入死循环

#### 总结

* 首先，check的设置，要具体问题具体分析，是`true`还是`false`都需要具体问题具体分析
* 如果出现，`l = mid + 1 `，则进行`mid = l + r >> 1 `
* 如果出现， `l = mid`,则进行`mid = l + r + 1 >> 1`

### 浮点数二分

原理和情况和整数二分都一样，设置精度  `r - l < 1e-8`即可

### 参考代码一  整数二分

```java
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 找绿色边界
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 找红色边界
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

### 参考代码二  浮点数二分

```java
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

## 整数二分例题

### 题目描述

给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。

对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。

如果数组中不存在该元素，则返回“-1 -1”。

### 输入格式

第一行包含整数n和q，表示数组长度和询问个数。

第二行包含n个整数（均在1~10000范围内），表示完整数组。

接下来q行，每行包含一个整数k，表示一个询问元素。

### 输出格式

共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。

如果数组中不存在该元素，则返回“-1 -1”。

### 数据范围

1≤n≤100000

1≤q≤10000

1≤k≤10000

### 样例

输入样例：

```java
6 3
1 2 2 3 3 4
3
4
5
```

输出样例：

```java
3 4
5 5
-1 -1
```

### 参考代码

```java
// 2022.2.27日 复习
#include <iostream>
using namespace std;
const int N = 1e5 + 10 ;
int n , q ;
int a[N];

int left(int x){
    int l = 1 , r = n ;
    while(l < r){
        int mid = l + r  >> 1 ;
        if(a[mid] >= x)   r = mid ;
        else              l = mid + 1;
    }
    if(a[l] != x)  return  -1 ;
    return l ; 
}
int right(int x){
    int l = 1 , r = n ; 
    while(l < r){
        int mid = l + r + 1 >> 1 ;
        if(a[mid] >  x)    r = mid - 1 ;
        else               l = mid ;
    }
    
    if(a[l] != x)  return  -1 ;
    return l ; 
}
int main(int argc, char const *argv[])
{
    cin >> n >> q ;
    for(int i = 1 ; i <= n ; ++i) cin >> a[i];
    while(q--){
        int k ; 
        cin >>  k ;
        int leftpos = left(k),rightpos = right(k);
        
        if(leftpos == -1 || rightpos == -1)  cout << "-1 -1"<<endl;
        else{
            cout <<leftpos - 1<<" "<<rightpos - 1<<endl;
        }
    }
    return 0;
}
```



## 浮点数二分例题

### 题目描述
给定一个浮点数n，求它的三次方根。
#### 输入格式
共一行，包含一个浮点数n。
#### 输出格式
共一行，包含一个浮点数，表示问题的解。
注意，结果保留6位小数。
#### 数据范围
一10000≤n≤10000
#### 输入样例：
1000.00
#### 输出样例：
10.000000

#### 注意

保留x为小数，则精度精确到下一位,即x+1位

#### 参考代码

```java
// 2022.2.27日 复习
#include <iostream>
using namespace std;
const double eps = 1e-7;
double n ;
int main(int argc, char const *argv[])
{
    cin >> n ;
    double l = -10000 ;
    double r = 10000 ;
    while(r -l > eps){
        double mid = (l + r) / 2 ;
        if(mid * mid * mid > n) r = mid ;
        else                    l = mid ;
    }
    printf("%0.6lf",l);
    return 0;
}
```



=======
---
title: 二分法
categories:
  - 基础算法
tags:
  - 二分法
  - week1
abbrlink: 64680
date: 2021-10-18 20:46:57
---

## 二分法

 整数二分： 有单调性一定可以二分  给定区间，定义某种性质，左区间不满足性质，右边区间。满足由于是整数二分，所以两个区间边界不重合<!-- more -->

移位运算的优先级小于算术运算，所以 l + r >> 1 无需加括号

### 二分本质： 寻找性质边界

一个问题有某个性质，左半边不满足，而右半边满足，则可以使用二分,寻找出性质边界。

### 整数二分

![picture](/img/erfen.jpg)

#### 二分出红色边界

* mid = (l  + r + 1) >> 1  （为何加1，看下面说明）
* if (check(mid))  为true，答案一定在[mid , r] 中 ， 更新方式  l = mid
* if (check(mid))  为false, 答案一定在[l,mid-1]中  ，更新方式 r = mid - 1

#### 二分出绿色边界

* mid = (l  + r) >> 1
* if (check(mid))  为true，答案一定在[l,mid] 中 ， 更新方式  r = mid
* if (check(mid))  为false, 答案一定在[mid+1,r]中，更新方式  l  = mid + 1

#### 解决实际问题步骤

首先写出check()函数，然后想找的红色还是绿色边界

#### 问题解答

 当 l =  r - 1 , mid = l + r >> 1 ,由于整数下取整，则 mid  = l 若为true , 则 l = mid ,其实就是l还是等于原来的l，陷入死循环

#### 总结

* 首先，check的设置，要具体问题具体分析，是`true`还是`false`都需要具体问题具体分析
* 如果出现，`l = mid + 1 `，则进行`mid = l + r >> 1 `
* 如果出现， `l = mid`,则进行`mid = l + r + 1 >> 1`

### 浮点数二分

原理和情况和整数二分都一样，设置精度  `r - l < 1e-8`即可

### 参考代码一  整数二分

```java
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 找绿色边界
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 找红色边界
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

### 参考代码二  浮点数二分

```java
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

## 整数二分例题

### 题目描述

给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。

对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。

如果数组中不存在该元素，则返回“-1 -1”。

### 输入格式

第一行包含整数n和q，表示数组长度和询问个数。

第二行包含n个整数（均在1~10000范围内），表示完整数组。

接下来q行，每行包含一个整数k，表示一个询问元素。

### 输出格式

共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。

如果数组中不存在该元素，则返回“-1 -1”。

### 数据范围

1≤n≤100000

1≤q≤10000

1≤k≤10000

### 样例

输入样例：

```java
6 3
1 2 2 3 3 4
3
4
5
```

输出样例：

```java
3 4
5 5
-1 -1
```

### 参考代码

```java
// 2022.2.27日 复习
#include <iostream>
using namespace std;
const int N = 1e5 + 10 ;
int n , q ;
int a[N];

int left(int x){
    int l = 1 , r = n ;
    while(l < r){
        int mid = l + r  >> 1 ;
        if(a[mid] >= x)   r = mid ;
        else              l = mid + 1;
    }
    if(a[l] != x)  return  -1 ;
    return l ; 
}
int right(int x){
    int l = 1 , r = n ; 
    while(l < r){
        int mid = l + r + 1 >> 1 ;
        if(a[mid] >  x)    r = mid - 1 ;
        else               l = mid ;
    }
    
    if(a[l] != x)  return  -1 ;
    return l ; 
}
int main(int argc, char const *argv[])
{
    cin >> n >> q ;
    for(int i = 1 ; i <= n ; ++i) cin >> a[i];
    while(q--){
        int k ; 
        cin >>  k ;
        int leftpos = left(k),rightpos = right(k);
        
        if(leftpos == -1 || rightpos == -1)  cout << "-1 -1"<<endl;
        else{
            cout <<leftpos - 1<<" "<<rightpos - 1<<endl;
        }
    }
    return 0;
}
```



## 浮点数二分例题

### 题目描述
给定一个浮点数n，求它的三次方根。
#### 输入格式
共一行，包含一个浮点数n。
#### 输出格式
共一行，包含一个浮点数，表示问题的解。
注意，结果保留6位小数。
#### 数据范围
一10000≤n≤10000
#### 输入样例：
1000.00
#### 输出样例：
10.000000

#### 注意

保留x为小数，则精度精确到下一位,即x+1位

#### 参考代码

```java
// 2022.2.27日 复习
#include <iostream>
using namespace std;
const double eps = 1e-7;
double n ;
int main(int argc, char const *argv[])
{
    cin >> n ;
    double l = -10000 ;
    double r = 10000 ;
    while(r -l > eps){
        double mid = (l + r) / 2 ;
        if(mid * mid * mid > n) r = mid ;
        else                    l = mid ;
    }
    printf("%0.6lf",l);
    return 0;
}
```



>>>>>>> 725fcb7a857252b3986fe8e21eadbeb0e3e3ddc6
=======
---
title: 二分法
categories:
  - 基础算法
tags:
  - 二分法
  - week1
abbrlink: 64680
date: 2021-10-18 20:46:57
---

## 二分法

 整数二分： 有单调性一定可以二分  给定区间，定义某种性质，左区间不满足性质，右边区间。满足由于是整数二分，所以两个区间边界不重合<!-- more -->

移位运算的优先级小于算术运算，所以 l + r >> 1 无需加括号

### 二分本质： 寻找性质边界

一个问题有某个性质，左半边不满足，而右半边满足，则可以使用二分,寻找出性质边界。

### 整数二分

![picture](/img/erfen.jpg)

#### 二分出红色边界

* mid = (l  + r + 1) >> 1  （为何加1，看下面说明）
* if (check(mid))  为true，答案一定在[mid , r] 中 ， 更新方式  l = mid
* if (check(mid))  为false, 答案一定在[l,mid-1]中  ，更新方式 r = mid - 1

#### 二分出绿色边界

* mid = (l  + r) >> 1
* if (check(mid))  为true，答案一定在[l,mid] 中 ， 更新方式  r = mid
* if (check(mid))  为false, 答案一定在[mid+1,r]中，更新方式  l  = mid + 1

#### 解决实际问题步骤

首先写出check()函数，然后想找的红色还是绿色边界

#### 问题解答

 当 l =  r - 1 , mid = l + r >> 1 ,由于整数下取整，则 mid  = l 若为true , 则 l = mid ,其实就是l还是等于原来的l，陷入死循环

#### 总结

* 首先，check的设置，要具体问题具体分析，是`true`还是`false`都需要具体问题具体分析
* 如果出现，`l = mid + 1 `，则进行`mid = l + r >> 1 `
* 如果出现， `l = mid`,则进行`mid = l + r + 1 >> 1`

### 浮点数二分

原理和情况和整数二分都一样，设置精度  `r - l < 1e-8`即可

### 参考代码一  整数二分

```java
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 找绿色边界
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 找红色边界
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

### 参考代码二  浮点数二分

```java
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

## 整数二分例题

### 题目描述

给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。

对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。

如果数组中不存在该元素，则返回“-1 -1”。

### 输入格式

第一行包含整数n和q，表示数组长度和询问个数。

第二行包含n个整数（均在1~10000范围内），表示完整数组。

接下来q行，每行包含一个整数k，表示一个询问元素。

### 输出格式

共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。

如果数组中不存在该元素，则返回“-1 -1”。

### 数据范围

1≤n≤100000

1≤q≤10000

1≤k≤10000

### 样例

输入样例：

```java
6 3
1 2 2 3 3 4
3
4
5
```

输出样例：

```java
3 4
5 5
-1 -1
```

### 参考代码

```java
// 2022.2.27日 复习
#include <iostream>
using namespace std;
const int N = 1e5 + 10 ;
int n , q ;
int a[N];

int left(int x){
    int l = 1 , r = n ;
    while(l < r){
        int mid = l + r  >> 1 ;
        if(a[mid] >= x)   r = mid ;
        else              l = mid + 1;
    }
    if(a[l] != x)  return  -1 ;
    return l ; 
}
int right(int x){
    int l = 1 , r = n ; 
    while(l < r){
        int mid = l + r + 1 >> 1 ;
        if(a[mid] >  x)    r = mid - 1 ;
        else               l = mid ;
    }
    
    if(a[l] != x)  return  -1 ;
    return l ; 
}
int main(int argc, char const *argv[])
{
    cin >> n >> q ;
    for(int i = 1 ; i <= n ; ++i) cin >> a[i];
    while(q--){
        int k ; 
        cin >>  k ;
        int leftpos = left(k),rightpos = right(k);
        
        if(leftpos == -1 || rightpos == -1)  cout << "-1 -1"<<endl;
        else{
            cout <<leftpos - 1<<" "<<rightpos - 1<<endl;
        }
    }
    return 0;
}
```



## 浮点数二分例题

### 题目描述
给定一个浮点数n，求它的三次方根。
#### 输入格式
共一行，包含一个浮点数n。
#### 输出格式
共一行，包含一个浮点数，表示问题的解。
注意，结果保留6位小数。
#### 数据范围
一10000≤n≤10000
#### 输入样例：
1000.00
#### 输出样例：
10.000000

#### 注意

保留x为小数，则精度精确到下一位,即x+1位

#### 参考代码

```java
// 2022.2.27日 复习
#include <iostream>
using namespace std;
const double eps = 1e-7;
double n ;
int main(int argc, char const *argv[])
{
    cin >> n ;
    double l = -10000 ;
    double r = 10000 ;
    while(r -l > eps){
        double mid = (l + r) / 2 ;
        if(mid * mid * mid > n) r = mid ;
        else                    l = mid ;
    }
    printf("%0.6lf",l);
    return 0;
}
```



>>>>>>> 725fcb7a857252b3986fe8e21eadbeb0e3e3ddc6
