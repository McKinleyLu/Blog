---
title: 整数二分
categories:
  - 基础算法
  - 竞赛
  - 竞赛模板
tags:
  - 二分法
  - c++
abbrlink: 64680
date: 2021-10-18 20:46:57
---

## 二分法

有单调性一定可以二分，否则也可能二分<!-- more -->

移位运算的优先级小于算术运算，所以 l + r >> 1 无需加括号

### 二分本质： 寻找性质边界

一个问题有某个性质，左半边不满足，而右半边满足，则可以使用二分,寻找出性质边界。

### 整数二分

#### 二分出红色边界

* mid = (l  + r + 1) >> 1  （为何加1，看下面说明）
* if (check(mid))  为true，答案一定在[mid , r] 中 ， 更新方式  l = mid
* if (check(mid))  为false, 答案一定在[l,mid-1]中  ，更新方式 r = mid - 1

#### 二分出绿色边界

* mid = (l  + r) >> 1
* if (check(mid))  为true，答案一定在[l,mid] 中 ， 更新方式  r = mid
* if (check(mid))  为false, 答案一定在[mid+1,r]中，更新方式  l  = mid + 1

#### 解决实际问题步骤

首先写出check()函数，然后想找的红色还是绿色边界

#### 问题解答

如果红色边界补不上加1，当l = r -1 ， 且情况为true时，会发现范围没有变

### 浮点数二分

原理和情况和整数二分都一样，设置精度  `r - l < 1e-8`即可

### 参考代码一  整数二分

```c++
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 找绿色边界
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 找红色边界
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

### 参考代码二  浮点数二分

```c++
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

