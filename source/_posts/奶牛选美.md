---
title: 奶牛选美
author: 瑾年
mathjax: true
summary: Acwing2022寒假每日一题
categories:
  - Acwing2022寒假每日一题
tags:
  - 算法
  - 2022WinterDay03
abbrlink: 35595
date: 2022-01-15 22:00:43
---

### 奶牛选美

听说最近两斑点的奶牛最受欢迎，约翰立即购进了一批两斑点牛。

不幸的是，时尚潮流往往变化很快，当前最受欢迎的牛变成了一斑点牛。<!-- more -->

约翰希望通过给每头奶牛涂色，使得它们身上的两个斑点能够合为一个斑点，让它们能够更加时尚。

牛皮可用一个` N×M`的字符矩阵来表示，如下所示：

```java
................
..XXXX....XXX...
...XXXX....XX...
.XXXX......XXX..
........XXXXX...
.........XXX....
```

其中，`X`表示斑点部分。

如果两个 `X` 在垂直或水平方向上相邻（对角相邻不算在内），则它们属于同一个斑点，由此看出上图中恰好有两个斑点。

约翰牛群里**所有的牛都有两个斑点**。

约翰希望通过使用油漆给奶牛尽可能少的区域内涂色，将两个斑点合为一个。

在上面的例子中，他只需要给三个 `.` 区域内涂色即可（新涂色区域用 `∗` 表示）：

```java
................
..XXXX....XXX...
...XXXX*...XX...
.XXXX..**..XXX..
........XXXXX...
.........XXX....
```

请帮助约翰确定，为了使两个斑点合为一个，他需要涂色区域的最少数量。

#### 输入格式

第一行包含两个整数 `N` 和` M`。

接下来 `N` 行，每行包含一个长度为 `M` 的由 `X` 和 `.` 构成的字符串，用来表示描述牛皮图案的字符矩阵。

#### 输出格式

输出需要涂色区域的最少数量。

#### 数据范围

`1≤N,M≤50`

#### 输入样例：

```java
6 16
................
..XXXX....XXX...
...XXXX....XX...
.XXXX......XXX..
........XXXXX...
.........XXX....
```

#### 输出样例：

```java
3
```

### 题解

首先本题是一道图论问题，模型简化为求两个非连通块的最短路径。

#### 知识点补充

搜索出两个连通块采用`flood_fill`算法，实现如下

* `DFS`:可能会爆栈，无法求出最短路
* `BFS`:如果边权只有`0`或`1`,可以求出最短路

距离

* 欧几里得距离：即使用`勾股定理求出斜边即为距离`
* 曼哈顿距离:`即d = |x1 - x 2| + |y1  -  y2|`

#### 方法

我们通过枚举两个连通图中点的距离，求出最小距离即为本题所求。时间复杂度为`O(n^2)`。

### 参考代码

```java
/**
 * @file day2.cpp
 * @author your name (you@domain.com)
 * @brief 
 * @version 0.1
 * @date 2022-01-15
 * 
 * @copyright Copyright (c) 2022
 * 
 */
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
const int N = 55 , M = 55 ;
typedef pair<int,int> PII;
vector<PII> points[2];
char g[N][N];
int n , m ;
int dx[4] = {-1,0,1,0} , dy[4] = {0,1,0,-1};
void dfs(int x , int y , vector<PII>&p){
    p.push_back({x,y});
    g[x][y] = '.';
    for(int i = 0 ; i < 4 ; ++i){
        int a = x + dx[i];
        int b = y + dy[i];
        if(a >= 0 && a < n  &&  b >= 0 && b < m && g[a][b] == 'X'){
               dfs(a,b,p);
        }
    }

}
int main(int argc, char const *argv[])
{
    cin >> n >> m;
    //input 
    for(int i = 0 ; i < n ; ++i){cin >> g[i];} 
    //calculate
    //dfs
    for(int i = 0 , k = 0 ; i < n ; ++i){
        for(int j = 0 ; j < m ; ++j){
            if(g[i][j] == 'X') {dfs(i,j,points[k++]);}
        }
    }
    //distans
    int res = 1e8;
    for (auto& a: points[0])
        for (auto& b: points[1])
            res = min(res, abs(a.first - b.first) + abs(a.second - b.second) - 1);
    cout<<res<<endl;
    return 0;
}

```

