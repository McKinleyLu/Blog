title: 最长上升子序列
categories:
  - 基础算法
tags:
  - 最长公共子序列
  - week5
abbrlink: 7935
date: 2023-01-30 15:03:12
---
### 题目描述

给定两个长度分别为`N`和`M`的字符串`A`和`B`，求既是`A`的子序列又是`B`的子序列的字符串长度最长是多少。

### **输入格式**

第一行包含两个整数N和M。

第二行包含一个长度为N的字符串，表示字符串A。第三行包含一个长度为M的字符串，表示字符串B。字符串均由小写字母构成。

### **输出格式**

输出一个整数，表示最大长度。

### 数据范围

`1 ≤ N,M ≤ 1000`

### 输入样例

```java
4 5 
acbd
abedc
```

### 输出样例

```java
3
```

### 题解

动态规划的状态表示： 

* 集合： `f[i,j]`A字符串前i个字串和B字符前j个字串构成的最大公共子序列
* 属性： max

状态计算：

* 00:  `a[i]` $\ne$`b[i]`,两个字符不相等  
* 01: `a[i]`在公共字符串中，而`b[i]`不在
* 10: `b[i]`在公共字符串中，而`a[i]`不在
* 11: `a[i]` $\eq$ $\eq$`b[i]`,两个字符相等  

状态转移方程：

* 如果`a[i]` $\eq$ $\eq$`b[i]`，则`f[i][j] = f[i-1][j-1]+1`
* 否则 `f[i][j] = max(f[i-1][j-1],max(f[i-1][j],f[i][j-1]))`

`f[i-1][j]`的含义是A字符串前`i-1`个字串和B字符前`j`个字串构成的最大公共子序列,而`10`状态的含义是`a[i]`不在公共子序列中，虽然两者含义不同，但是`f[i-1][j]`包含了`a[i]`不在公共子序列中的情况，因此可以使用`f[i][j] = max(f[i-1][j-1],max(f[i-1][j],f[i][j-1]))`来处理这种情况。

### 参考代码

```java
#include <iostream>
#include <string>
using namespace std ;
const int N = 1e3+10 , M = 1e3+10 ;
char a[N],b[M];
int n ,m ;
int f[N][M];
int main(int argc, char const *argv[])
{
    cin >> n >> m >> a+1 >> b+1 ;
    for(int i = 1; i <= n ; ++i){
        for(int j = 1 ; j <= m ; ++j){
            // 00 01 10 11
            f[i][j] = max(f[i][j-1],f[i-1][j]);
            if(a[i] == b[j]) f[i][j] = max(f[i][j],f[i-1][j-1] + 1);
        }
    }
    cout << f[n][m];
    return 0;
}
```





















