---
title: 最短路 - 朴素迪杰斯特拉 && 堆优化迪杰斯特拉
categories:
  - 基础算法
  - 竞赛
  - 竞赛模板
tags:
  - 最短路
  - 迪杰斯特拉
  - c++
abbrlink: 15728
date: 2021-11-20 16:29:37
---

### 知识点

初始化  dist[1] = 0 dist[i]  = MAX

 每次找当前最短路的点(贪心)

 for  i  in range( 1 - n)

​         t 不在 s集合中，且距离起点路径最短

​         s <- t

​        用t更新到其他所有点的距离

迪杰斯特拉图示：<!-- more -->

![picture](/img/dijkstra.png)

### 题目描述

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为正值。

请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。

#### 输入格式

第一行包含整数 n 和 m。

接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。

#### 输出格式 

如果路径不存在，则输出 −1。

#### 数据范围

1≤n≤500,

1≤m≤105,

图中涉及边长均不超过10000。

#### 输入样例：

```java
3 3

1 2 2

2 3 1

1 3 4
```

#### 输出样例：

```java
3
```

#### 参考代码：

```java
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 510;
int dist[N];
int g[N][N];
bool used[N];
int n , m ;
int dijkstra(){
    memset(dist, 0x3f , sizeof dist);
    memset(used,false,sizeof used);
    dist[1] = 0;
    for(int i = 1 ; i <= n ; ++i){
        //找出未访问过且距离原点最近的点
        //t 不在 s集合中，且距离起点路径最短
        int t = - 1;
        for(int j = 1 ; j <= n ; ++j){
            if(!used[j] && (t == -1 || dist[t] > dist[j])){
                t = j ;
            }
        }


        used[t] = true ;  // t这个点被加入到S集合

        for(int j = 1 ; j <= n ; ++j){
            dist[j] = min(dist[j], dist[t] + g[t][j]);
        }
    }
    if(dist[n] == 0x3f3f3f3f)       return -1;
    else                            return dist[n];

}
int main(){
    cin >> n >> m;
    memset(g , 0x3f , sizeof g);
    for(int i = 1 , x ,y , w; i <= m ; ++i){
        cin >> x >> y >> w;
        g[x][y] = min(g[x][y],w) ;
    }
    cout<<dijkstra()<<endl;

    return 0 ;
}
```

### 堆优化迪杰斯特拉

如果是稀疏图，若n特别大，会发生堆内存溢出
迪杰斯特拉找一个离原点最小的数计算量最大，是n^2
 从一堆数找一个最小的数，堆是O(1),修改一个数是O(logn)
用对存储所有点到原点的距离手写堆，保证堆仅仅只有n个元素也可以使用优先队列，但是不允许修改一个数，只能插入，从而创造了冗余。

这里采用STL中的堆

#### 参考代码

```java
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
typedef pair<int ,int> PLL;
const int N = 1e5+10;
int n , m ;
int h[N] , en[N],ne[N] , w[N];
int dist[N];
bool used[N];
int idx = 0 ;
//稀疏图，邻接表存储
void add_node(int a , int b , int c){
    en[idx] = b , ne[idx] = h[a] , w[idx] = c , h[a] = idx++ ;
}

int dijkstra(){
     memset(dist , 0x3f , sizeof(dist));
     dist[1] = 0 ;

     priority_queue<PLL , vector<PLL> , greater<PLL>> heap;
     // 1号点，距离为0
     heap.push({0,1});
     while (heap.size()){
         auto top = heap.top();
         heap.pop();
         
        int ver = top.second , distance = top.first ;
        if (used[ver]) continue;                      //  排除冗余的计算
        for(int i = h[ver] ; i != - 1 ; i = ne[i]){
            int j = en[ver];
            if(dist[j] > distance + w[j] ){
                dist[j] = distance + w[j];
                heap.push({dist[j],j});
            } 
        }
     }
     
    if(dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main(int argc, char const *argv[])
{
    cin >> n >> m;
    memset(h , -1 , sizeof h);
    
    while(m --){

    int a , b , c  ;
    cin >> a >> b >> c ;
    add_node(a,b,c);
    }

    cout<<dijkstra()<<endl;
    return 0;
}

```

